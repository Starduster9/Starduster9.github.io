<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Formation Detector + Troop Inference (OpenCV.js + ONNX Runtime Web)</title>
<style>
:root{--bg:#0b0d10;--card:#12161b;--ink:#e6edf3;--muted:#9aa7b5;--accent:#5b9cff;--ok:#28a745;--err:#ff5d5d}
html,body{margin:0;background:var(--bg);color:var(--ink);font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Noto Sans,Apple SD Gothic Neo,Malgun Gothic,sans-serif}
header{display:flex;gap:12px;align-items:center;padding:16px 20px;border-bottom:1px solid #1e242c}
header h1{font-size:16px;margin:0;letter-spacing:.2px}
.badge{padding:2px 8px;border-radius:999px;background:#1a2330;border:1px solid #2a3442;color:var(--muted)}
main{display:grid;grid-template-columns:360px 1fr;gap:16px;padding:16px}
.panel{background:var(--card);border:1px solid #1e242c;border-radius:16px;padding:14px}
.panel h2{margin:0 0 12px 0;font-size:14px;color:var(--muted);font-weight:600}
.row{display:flex;gap:8px;align-items:center;margin-bottom:10px}
input[type=file]{width:100%}
.btn{appearance:none;background:var(--accent);color:#fff;border:none;padding:10px 12px;border-radius:10px;font-weight:600;cursor:pointer}
.btn[disabled]{opacity:.6;cursor:default}
label{color:var(--muted);font-size:12px}
.grid{display:grid;grid-template-columns:repeat(3, minmax(200px,1fr));gap:12px}
.slot{background:#0f1318;border:1px dashed #2a3442;border-radius:12px;padding:8px}
.slot h3{margin:0 0 8px 0;font-size:12px;color:var(--muted)}
canvas{display:block;width:100%;height:auto;background:#0b0d10;border-radius:8px}
.note{color:var(--muted);font-size:12px}
.split{display:grid;grid-template-columns:1fr 1fr;gap:12px}
.kv{display:grid;grid-template-columns:120px 1fr;gap:6px 10px}
footer{padding:10px 16px;color:var(--muted);border-top:1px solid #1e242c}
.progress-card{margin-top:12px;background:#0f1318;border:1px solid #2a3442;border-radius:12px;padding:12px}
.progress-bar{position:relative;height:10px;width:100%;background:#11161d;border:1px solid #2a3442;border-radius:999px;overflow:hidden}
.progress-bar>span{display:block;height:100%;width:0%;background:linear-gradient(90deg,var(--accent),#7db5ff);transition:width .15s ease}
.progress-head{display:flex;gap:8px;align-items:center;margin-top:8px;flex-wrap:wrap}
.progress-head .step{font-weight:600}
.progress-head .pct,.progress-head .elapsed{color:var(--muted);font-size:12px}
.logs{margin-top:8px;max-height:180px;overflow:auto;background:#0b0f14;border:1px solid #1e2330;border-radius:8px}
.logs pre{margin:0;padding:8px 10px;font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;font-size:12px;white-space:pre-wrap;word-break:break-word}
.success{color:var(--ok)}
.error{color:var(--err)}
/* 패치 보드 */
.grid7{display:grid;grid-template-columns:repeat(7, minmax(40px,1fr));gap:8px}
.gridHeroes{display:grid;grid-template-columns:repeat(3, minmax(64px,1fr));gap:8px}
.subhead{margin:10px 0 6px 0;color:var(--muted);font-size:12px;font-weight:600}
.cellWrap{display:flex;flex-direction:column;gap:6px}
.cellWrap h4{margin:0;font-size:11px;color:var(--muted)}
.cellWrap canvas{width:100%;height:auto;border-radius:8px;background:#0b0d10}
/* Export */
.export{display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-top:12px}
textarea.code{width:100%;min-height:160px;background:#0b0f14;color:#cfe3ff;border:1px solid #1e2330;border-radius:8px;padding:8px;font-family:ui-monospace,Menlo,Consolas,monospace;font-size:12px}
.btnRow{display:flex;gap:8px;flex-wrap:wrap;margin-top:6px}
small.hint{color:var(--muted)}
</style>

<!-- OpenCV.js: 두 개 CDN 시도 + 런타임 폴링 -->
<script>
(function(){
  let statusEl=null, readyCalled=false, pollId=null;
  function setStatus(t){ if(!statusEl)statusEl=document.getElementById('status'); if(statusEl)statusEl.textContent=t; }
  function callReadyOnce(){ if(!readyCalled){ readyCalled=true; if(typeof onCvReady==='function') onCvReady(); } }
  window.onOpenCvLoaded=function(){
    if (typeof cv !== 'undefined'){
      cv['onRuntimeInitialized'] = function(){ callReadyOnce(); };
      let t0=performance.now();
      pollId = setInterval(()=>{
        try{
          if (cv && cv.Mat && typeof cv.imread === 'function'){
            callReadyOnce(); clearInterval(pollId);
          }
          if (performance.now()-t0>10000) clearInterval(pollId);
        }catch(_){}
      },100);
    }
  };
  const urls=['https://docs.opencv.org/4.10.0/opencv.js','https://cdn.jsdelivr.net/npm/opencv.js@4.10.0/dist/opencv.js'];
  let i=0;
  function loadNext(){
    if(i>=urls.length){setStatus('OpenCV.js 로드 실패');return;}
    const u=urls[i++]; setStatus('OpenCV.js 로딩 중… '+u);
    const s=document.createElement('script'); s.src=u; s.async=true;
    s.onload=function(){setStatus('OpenCV.js 스크립트 로드됨'); if(typeof onOpenCvLoaded==='function') onOpenCvLoaded(); };
    s.onerror=function(){setStatus('로드 실패: '+u); loadNext();};
    document.head.appendChild(s);
  }
  loadNext();
  setTimeout(function(){
    if(!(window.cv&&cv.Mat)){ setStatus('초기화 지연: 대체 CDN 시도'); loadNext(); }
  },10000);
})();
</script>

<!-- ONNX Runtime Web -->
<script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
<script>
  // 우선 순위: webgpu -> wasm
  const ORT_EP_ORDER = ['webgpu', 'wasm'];
</script>
</head>

<body>
<header>
  <h1>Formation Detector + Troop Inference</h1>
  <span class="badge">OpenCV.js · ONNX Runtime Web</span>
</header>

<main>
  <section class="panel" id="controls">
    <h2>입력 & 설정</h2>
    <div class="row"><input id="file" type="file" accept="image/*" /></div>
    <div class="kv">
      <label for="sizeFull">size_full</label>
      <input id="sizeFull" type="number" value="1024" min="256" max="4096" />
      <label for="sizePatch">size_patch</label>
      <input id="sizePatch" type="number" value="32" min="8" max="512" />
      <label for="angleDeg">교차 각 임계(angle_deg)</label>
      <input id="angleDeg" type="number" value="45" min="0" max="90" />
      <label for="brush">브러시 반경(px)</label>
      <input id="brush" type="number" value="5" min="1" max="40" />
    </div>
    <div class="row">
      <button id="run" class="btn" disabled>실행 (탐지 → 추론 → 출력)</button>
      <span class="note" id="status">OpenCV.js 초기화 대기중…</span>
    </div>

    <!-- Progress Card -->
    <div class="progress-card">
      <div class="progress-bar"><span id="bar"></span></div>
      <div class="progress-head">
        <span class="step" id="stepText">대기 중</span>
        <span class="pct" id="pctText">0%</span>
        <span class="elapsed" id="elapsed">경과 0.0s</span>
      </div>
      <details>
        <summary style="cursor:pointer;margin-top:6px;color:var(--muted)">세부 로그</summary>
        <div class="logs"><pre id="log"></pre></div>
      </details>
    </div>
  </section>

  <section class="panel">
    <h2>결과</h2>
    <div class="split">
      <div class="slot"><h3>원본</h3><canvas id="cOrig"></canvas></div>
      <div class="slot"><h3>탐지 결과(라인/클러스터)</h3><canvas id="cDebug"></canvas></div>
    </div>
    <div class="split" style="margin-top:12px">
      <div class="slot"><h3>Ally (워프)</h3><canvas id="cAlly"></canvas></div>
      <div class="slot"><h3>Enemy (워프)</h3><canvas id="cEnemy"></canvas></div>
    </div>

    <!-- 패치 보드 -->
    <div class="split" style="margin-top:12px">
      <div class="slot">
        <h3>Ally – Troops (7×7)</h3>
        <div id="gridAlly" class="grid7"></div>
        <div class="subhead">Ally – Heroes</div>
        <div id="heroAlly" class="gridHeroes"></div>
      </div>
      <div class="slot">
        <h3>Enemy – Troops (7×7)</h3>
        <div id="gridEnemy" class="grid7"></div>
        <div class="subhead">Enemy – Heroes</div>
        <div id="heroEnemy" class="gridHeroes"></div>
      </div>
    </div>

    <!-- Export (JSON & Base64 + Copy) -->
    <h3 style="margin-top:16px;color:var(--muted);font-size:12px">Export</h3>
    <div class="export">
      <div class="slot">
        <h3>Ally JSON</h3>
        <textarea id="allyJson" class="code" readonly></textarea>
        <div class="btnRow">
          <button id="copyAllyJson" class="btn">Ally JSON 복사</button>
          <button id="copyAllyB64"  class="btn">Ally Base64 복사</button>
        </div>
        <small class="hint" id="allyHint"></small>
      </div>
      <div class="slot">
        <h3>Enemy JSON</h3>
        <textarea id="enemyJson" class="code" readonly></textarea>
        <div class="btnRow">
          <button id="copyEnemyJson" class="btn">Enemy JSON 복사</button>
          <button id="copyEnemyB64"  class="btn">Enemy Base64 복사</button>
        </div>
        <small class="hint" id="enemyHint"></small>
      </div>
    </div>

    <h3 style="margin-top:16px;color:var(--muted);font-size:12px">중간 결과</h3>
    <div class="grid" id="dbgGrid"></div>
  </section>
</main>

<footer>브라우저에서 온디바이스 추론 (OpenCV.js + ONNX Runtime Web). 파일은 로컬에서만 처리됩니다.</footer>

<script>
/* ============== Progress Manager ============== */
const nextFrame = () => new Promise(r=>requestAnimationFrame(()=>r()));
class Progress {
  constructor() {
    this.bar = document.getElementById('bar');
    this.stepText = document.getElementById('stepText');
    this.pctText = document.getElementById('pctText');
    this.elapsedEl = document.getElementById('elapsed');
    this.logEl = document.getElementById('log');
    this.totalWeight = 100;
    this.doneWeight = 0;
    this.startTs = 0;
  }
  start(totalWeight=100){
    this.totalWeight = totalWeight;
    this.doneWeight = 0;
    this.startTs = performance.now();
    this._render(0, '준비 중');
    this._log('--- 시작 ---');
  }
  _render(pct, step){
    this.bar.style.width = `${Math.max(0,Math.min(100,pct))}%`;
    this.pctText.textContent = `${pct.toFixed(0)}%`;
    if (step) this.stepText.textContent = step;
    const elapsed = (performance.now() - this.startTs)/1000;
    this.elapsedEl.textContent = `경과 ${elapsed.toFixed(1)}s`;
  }
  _log(s){ this.logEl.textContent += s + '\n'; this.logEl.parentElement.scrollTop = this.logEl.parentElement.scrollHeight; }
  async step(label, weight, fn){
    const begin = performance.now();
    this._render(this.doneWeight / this.totalWeight * 100, label);
    this._log(`▶ ${label}…`);
    await nextFrame();
    let ret;
    try { ret = await fn(); }
    catch (e) { this._log(`✖ ${label} 실패: ${e.message || e}`); throw e; }
    finally { this._log(`✓ ${label} 완료 (${(performance.now()-begin).toFixed(1)} ms)`); }
    this.doneWeight += weight;
    this._render(this.doneWeight / this.totalWeight * 100, label);
    await nextFrame();
    return ret;
  }
  finish(ok=true, msg='완료'){
    this._render(100, msg);
    this._log(ok? `=== 성공: ${msg} ===` : `=== 종료: ${msg} ===`);
    this.stepText.classList.toggle('error', !ok);
    this.stepText.classList.toggle('success', ok);
  }
}

/* ============== OpenCV Ready Hook ============== */
let cvReady=false, srcMat=null;
function onCvReady(){
  cvReady=true;
  const runEl=document.getElementById('run');
  if (runEl) runEl.disabled=false;
  const st=document.getElementById('status');
  if (st) st.textContent='OpenCV.js 준비 완료';
}

/* ============== Common CV Utils ============== */
function matFromImage(img){ const m=cv.imread(img); let rgb=new cv.Mat(); cv.cvtColor(m,rgb,cv.COLOR_RGBA2RGB); m.delete(); return rgb; }
function toGray(mat){ if (mat.type()===cv.CV_8UC1) return mat.clone(); let g=new cv.Mat(); cv.cvtColor(mat,g,cv.COLOR_RGB2GRAY); return g; }
function drawLinesOn(mat, lines, color=[255,0,0], thickness=2){
  const col = new cv.Scalar(color[0]??255, color[1]??0, color[2]??0, 255);
  const out = mat.clone();
  for (let i=0; i<lines.length; i++){
    const [x1,y1,x2,y2] = lines[i];
    cv.line(out, new cv.Point(x1|0,y1|0), new cv.Point(x2|0,y2|0), col, thickness, cv.LINE_AA);
  }
  return out;
}
function canvasFromMat(mat, canvasOrEl){
  const canvas = (typeof canvasOrEl === 'string')
    ? document.getElementById(canvasOrEl)
    : canvasOrEl;
  if (!canvas) throw new Error('canvas element not found');
  if (!mat || typeof mat.cols !== 'number' || typeof mat.rows !== 'number') return; // [FIX] deleted guard
  if (canvas.width !== mat.cols || canvas.height !== mat.rows){
    canvas.width  = mat.cols;
    canvas.height = mat.rows;
  }
  cv.imshow(canvas, mat);
}
function makeDbgSlot(title){
  const wrap = document.createElement('div');
  wrap.className = 'slot';
  const h3 = document.createElement('h3'); h3.textContent = title;
  const canvas = document.createElement('canvas');
  canvas.style.width = '100%'; canvas.style.height = 'auto'; canvas.style.display = 'block';
  canvas.style.borderRadius = '8px'; canvas.style.background = '#0b0d10';
  wrap.appendChild(h3); wrap.appendChild(canvas);
  return { wrap, canvas };
}
function percentileGray(mat, perc){
  const images=new cv.MatVector(); images.push_back(mat);
  const channels=[0], mask=new cv.Mat(), hist=new cv.Mat(), histSize=[256], ranges=[0,256];
  cv.calcHist(images, channels, mask, hist, histSize, ranges);
  const total=mat.rows*mat.cols, target=Math.max(0,Math.min(1,perc/100))*total;
  let cum=0, thr=255; for (let i=0;i<256;i++){ cum+=hist.floatAt(i,0); if (cum>=target){thr=i;break;} }
  images.delete(); mask.delete(); hist.delete(); return thr|0;
}
function fastDilateBinary(mask, kSize=3){
  const r = Math.max(1, Math.floor(kSize/2));
  let inv = new cv.Mat(); cv.bitwise_not(mask, inv);
  let dist = new cv.Mat(); cv.distanceTransform(inv, dist, cv.DIST_L2, 3);
  inv.delete();
  let out = new cv.Mat(); cv.threshold(dist, out, r, 255, cv.THRESH_BINARY_INV);
  dist.delete();
  let u8 = new cv.Mat(); out.convertTo(u8, cv.CV_8U); out.delete();
  return u8;
}
function fastErodeBinary(mask, kSize=3){
  const r = Math.max(1, Math.floor(kSize/2));
  let dist = new cv.Mat(); cv.distanceTransform(mask, dist, cv.DIST_L2, 3);
  let out  = new cv.Mat(); cv.threshold(dist, out, r, 255, cv.THRESH_BINARY);
  dist.delete();
  let u8 = new cv.Mat(); out.convertTo(u8, cv.CV_8U); out.delete();
  return u8;
}
function fastOpenBinary(mask, kSize=3){ const er = fastErodeBinary(mask, kSize); const di = fastDilateBinary(er,  kSize); er.delete(); return di; }
function fastCloseBinary(mask, kSize=3){ const di = fastDilateBinary(mask, kSize); const er = fastErodeBinary(di,  kSize); di.delete(); return er; }
function brightnessMask(gray, perc){ const thr=percentileGray(gray, perc); let m=new cv.Mat(); cv.threshold(gray,m,thr,255,cv.THRESH_BINARY); return m; }
function removeSmallComponents(mask, minArea=100, area_w_wh=false){
  let labels=new cv.Mat(), stats=new cv.Mat(), cents=new cv.Mat();
  const n=cv.connectedComponentsWithStats(mask, labels, stats, cents, 4, cv.CV_32S);
  const keep=new Set();
  for (let i=1;i<n;i++){
    const area=stats.intAt(i,cv.CC_STAT_AREA);
    const w=stats.intAt(i,cv.CC_STAT_WIDTH), h=stats.intAt(i,cv.CC_STAT_HEIGHT);
    if ((area_w_wh ? (w*h>=minArea) : (area>=minArea))) keep.add(i);
  }
  // maskFromLabelsSet inline
  const rows=labels.rows, cols=labels.cols, N=rows*cols;
  const L = labels.data32S;
  let out = new cv.Mat.zeros(rows, cols, cv.CV_8U);
  const M = out.data;
  for (let i=0;i<N;i++){ const v = L[i]; if (v>=1 && keep.has(v)) M[i]=255; }
  labels.delete(); stats.delete(); cents.delete();
  return out;
}
function sampleLineVals(mat, line){
  let [x1,y1,x2,y2]=line.map(v=>Math.round(v));
  const cols=mat.cols, rows=mat.rows, type=mat.type();
  const data8  = (type===cv.CV_8U ) ? mat.data   : null;
  const data32F= (type===cv.CV_32F) ? mat.data32F: null;
  const data32S= (type===cv.CV_32S) ? mat.data32S: null;
  const dx = x2 - x1, dy = y2 - y1;
  const steps = Math.max(Math.abs(dx), Math.abs(dy)) || 1;
  const sx = dx / steps, sy = dy / steps;
  let x = x1, y = y1; const vals = [];
  for (let i=0;i<=steps;i++){
    const xi = x|0, yi = y|0;
    if (xi>=0 && xi<cols && yi>=0 && yi<rows){
      const idx = yi*cols + xi; let v=0;
      if (data8)   v = data8[idx];
      else if (data32F) v = data32F[idx];
      else if (data32S) v = data32S[idx];
      else v = mat.ucharAt(yi,xi);
      vals.push(v);
    }
    x += sx; y += sy;
  }
  return { vals };
}
function countIntersectionsByPaint(lines, brushSize, angleDeg, imgShape){
  const [H, W] = imgShape; const N = lines.length | 0; const eps = 1e-9;
  const angleThr = (angleDeg * Math.PI/180) || (30 * Math.PI/180);
  const rBase = Math.max(1, brushSize | 0);
  function ang(l){ return Math.atan2(l[3]-l[1], l[2]-l[0]); }
  function intersect(l1,l2){
    const [x1,y1,x2,y2]=l1, [x3,y3,x4,y4]=l2;
    const den=(x2-x1)*(y4-y3)-(y2-y1)*(x4-x3);
    if (Math.abs(den) < eps) return null;
    const t=((x3-x1)*(y4-y3)-(y3-y1)*(x4-x3))/den;
    return [x1 + t*(x2-x1), y1 + t*(y2-y1)];
  }
  const mask = new cv.Mat.zeros(H, W, cv.CV_8U);
  const angles = new Array(N); for (let i=0;i<N;i++) angles[i] = ang(lines[i]);
  for (let i=0;i<N;i++){
    const ai = angles[i], li = lines[i];
    for (let j=i+1;j<N;j++){
      let d = Math.abs(ai - angles[j]); if (d > Math.PI) d = 2*Math.PI - d;
      if (d + 1e-9 < angleThr) continue;
      const P = intersect(li, lines[j]); if (!P) continue;
      const cx = Math.round(P[0]), cy = Math.round(P[1]);
      const dx = (cx < 0) ? -cx : (cx > (W-1) ? (cx-(W-1)) : 0);
      const dy = (cy < 0) ? -cy : (cy > (H-1) ? (cy-(H-1)) : 0);
      const overflow = Math.max(dx, dy);
      const cap = Math.min(Math.floor(Math.max(H, W) / 20), 48);
      const r = rBase + Math.min(overflow * 3, cap);
      cv.circle(mask, new cv.Point(cx, cy), r|0, new cv.Scalar(255,255,255,255), -1);
    }
  }
  let labels=new cv.Mat(), stats=new cv.Mat(), cents=new cv.Mat();
  const n = cv.connectedComponentsWithStats(mask, labels, stats, cents, 4, cv.CV_32S);
  mask.delete(); stats.delete(); cents.delete();
  return { count: Math.max(n-1,0), labels };
}
function buildLabelGraphFromLines(lines, labels){
  function edgeKey(a,b){ return a<b ? (a+'-'+b) : (b+'-'+a); }
  const adj=new Map(); const edges=new Map();
  function addEdge(a,b){
    if (!adj.has(a)) adj.set(a,new Set());
    if (!adj.has(b)) adj.set(b,new Set());
    adj.get(a).add(b); adj.get(b).add(a);
    edges.set(edgeKey(a,b), true);
  }
  for (let idx=0; idx<lines.length; idx++){
    const {vals}=sampleLineVals(labels, lines[idx]); const seq=vals.map(v=>v|0).filter(v=>v>=1);
    if (seq.length<2) continue;
    const uniq=[]; for(let k=0;k<seq.length;k++){ if (k===0 || seq[k]!==seq[k-1]) uniq.push(seq[k]); }
    for (let k=0;k<uniq.length-1;k++){
      const a=uniq[k], b=uniq[k+1]; if (a===b) continue; addEdge(a,b);
    }
  }
  const cycles=new Set();
  const norm=(cyc)=>{
    const r=cyc.slice(); const m=Math.min(...r); const i=r.indexOf(m);
    const rot=r.slice(i).concat(r.slice(0,i));
    const rev=[rot[0],rot[3],rot[2],rot[1]];
    const a=rot.join('-'), b=rev.join('-');
    return a<b? a : b;
  };
  for (const u of adj.keys()){
    for (const v of (adj.get(u)||new Set()).keys()) if (v>u){
      for (const x of (adj.get(u)||new Set()).keys()) if (x>u && x!==v){
        for (const y of (adj.get(v)||new Set()).keys()) if (y>v && y!==u){
          if ((adj.get(x)||new Set()).has(y)) cycles.add(norm([u,v,y,x]));
        }
      }
    }
  }
  return { cycles:[...cycles].map(s=>s.split('-').map(Number)) , adj, edges };
}
function abcline(line){ const [x1,y1,x2,y2]=line.map(Number); const dx=x2-x1, dy=y2-y1; const a=dy,b=-dx,c=-(a*x1+b*y1); return {a,b,c}; }
function intersectLines(l1,l2){ const A=abcline(l1), B=abcline(l2); const det=A.a*B.b-B.a*A.b; if (Math.abs(det)<1e-9) return [NaN,NaN]; const x=(A.b*B.c-B.b*A.c)/det, y=(A.c*B.a-B.c*A.a)/det; return [x,y]; }
function polygonArea(pts){ if (pts.some(p=>!isFinite(p[0])||!isFinite(p[1]))) return 0; let s=0; for (let i=0;i<pts.length;i++){ const [x1,y1]=pts[i],[x2,y2]=pts[(i+1)%pts.length]; s+=x1*y2 - y1*x2; } return Math.abs(0.5*s); }
function orderCornersTLTRBRBL(pts){
  const arr = pts.map(p => ({ p, s: p[0] + p[1], d: p[0] - p[1] }));
  const tl = arr.reduce((a,b) => a.s < b.s ? a : b).p;
  const br = arr.reduce((a,b) => a.s > b.s ? a : b).p;
  const tr = arr.reduce((a,b) => a.d > b.d ? a : b).p;
  const bl = arr.reduce((a,b) => a.d < b.d ? a : b).p;
  return [tl,tr,br,bl];
}
function normalizeForView(mat32f){ const mm=cv.minMaxLoc(mat32f); let out=new cv.Mat(); const scale=(mm.maxVal>0? 255.0/mm.maxVal : 1.0); mat32f.convertTo(out, cv.CV_8U, scale, 0); return out; }
function labelToColor(labels){
  let lab32f = new cv.Mat(); labels.convertTo(lab32f, cv.CV_32F);
  const mm = cv.minMaxLoc(lab32f); lab32f.delete();
  let val8 = new cv.Mat(); const scale = mm.maxVal > 0 ? 255.0 / mm.maxVal : 1.0;
  labels.convertTo(val8, cv.CV_8U, scale, 0);
  let R = val8.clone();
  let G = new cv.Mat(val8.rows, val8.cols, cv.CV_8U, new cv.Scalar(0));
  let S255 = new cv.Mat(val8.rows, val8.cols, cv.CV_8U, new cv.Scalar(255));
  cv.subtract(S255, val8, G);
  let B = new cv.Mat(val8.rows, val8.cols, cv.CV_8U, new cv.Scalar(0));
  let S128 = new cv.Mat(val8.rows, val8.cols, cv.CV_8U, new cv.Scalar(128));
  cv.absdiff(val8, S128, B);
  let mv = new cv.MatVector(); mv.push_back(B); mv.push_back(G); mv.push_back(R);
  let out = new cv.Mat(); cv.merge(mv, out);
  mv.delete(); B.delete(); G.delete(); R.delete(); S128.delete(); S255.delete(); val8.delete();
  return out;
}

/* ============== Detect + Recognize ============== */
async function detectAndRecognize(imgRGB, opts, progress){
  const H=imgRGB.rows, W=imgRGB.cols; const dbg=[];
  progress.start(100);
  const gray = await progress.step('Grayscale', 2, async ()=> toGray(imgRGB));
  const e_log = await progress.step('LoG edges', 6, async ()=>{
    let lap=new cv.Mat(); cv.Laplacian(gray,lap,cv.CV_16S,3,1,0,cv.BORDER_DEFAULT);
    let lapAbs=new cv.Mat(); cv.convertScaleAbs(lap,lapAbs); lap.delete();
    let thr=percentileGray(lapAbs,75); let bw=new cv.Mat(); cv.threshold(lapAbs,bw,thr,255,cv.THRESH_BINARY); lapAbs.delete();
    dbg.push(['LoG edges', bw.clone()]);
    return bw;
  });
  const flatRefined = await progress.step('Morph + flat refine', 16, async ()=>{
    const e_close = fastCloseBinary(e_log,3);
    let flat = new cv.Mat(); cv.bitwise_not(e_close, flat); e_close.delete();
    const minAreaThin = (H*W/2000)|0;
    let flat2 = removeSmallComponents(flat, minAreaThin); flat.delete();
    const ksize = (Math.max(H,W)/200)|0;
    const flatDil = fastDilateBinary(flat2, Math.max(ksize,1));
    let flatNei = new cv.Mat(); cv.bitwise_xor(flatDil, flat2, flatNei); flatDil.delete();
    const bmask75 = brightnessMask(gray,75);
    const bmaskDil = fastDilateBinary(bmask75, Math.max(6*ksize,1));
    let eRef = new cv.Mat(); cv.bitwise_and(flatNei, bmaskDil, eRef);
    flatNei.delete(); bmaskDil.delete(); bmask75.delete();
    eRef = fastOpenBinary(eRef, Math.max((ksize/2)|0,1));
    const eRefClean = removeSmallComponents(eRef, (H * W / 20) | 0, true); eRef.delete();
    let eRef2 = new cv.Mat(); cv.bitwise_and(eRefClean, brightnessMask(gray,75), eRef2); eRefClean.delete();
    dbg.push(['log_refined', eRef2.clone()]);
    return eRef2;
  });
  const bandAndLines = await progress.step('Hough & intersections', 12, async ()=>{
    const scale=0.5;
    let small = new cv.Mat(); cv.resize(flatRefined, small, new cv.Size(0,0), scale, scale, cv.INTER_NEAREST);
    let linesP = new cv.Mat();
    cv.HoughLinesP(small, linesP, 1.0, Math.PI/720, Math.max(H, W)/16|0, (Math.max(H, W)/12|0)*scale, (Math.max(H, W)/12|0)*scale);
    const lines = [];
    for (let i=0;i<linesP.rows;i++){
      lines.push([
        (linesP.intAt(i,0) / scale) | 0,
        (linesP.intAt(i,1) / scale) | 0,
        (linesP.intAt(i,2) / scale) | 0,
        (linesP.intAt(i,3) / scale) | 0
      ]);
    }
    linesP.delete(); small.delete();
    dbg.push(['hough', drawLinesOn(imgRGB, lines, [255,128,0], 2)]);
    const inter = countIntersectionsByPaint(lines, opts.brush|0, opts.angleDeg|0, [H, W]);
    dbg.push(['intersection_map', labelToColor(inter.labels)]);
    return { eRef2: flatRefined, lines, lblMap: inter.labels };
  });
  const { eRef2, lines, lblMap } = bandAndLines;

  const warpRes = await progress.step('Graph/Corners & Warp & Patches', 52, async ()=>{
    // 군집
    const clusters=(function(){
      const m = new Map();
      for(let idx=0; idx<lines.length; idx++){
        const {vals}=sampleLineVals(lblMap, lines[idx]); const s=new Set();
        for (const v of vals){ if ((v|0)>=1) s.add(v|0); }
        const key=[...s].sort((a,b)=>a-b).join('-');
        if (!m.has(key)) m.set(key, []);
        m.get(key).push(idx);
      }
      const keys=[...m.keys()], rm=new Set();
      for (let i=0;i<keys.length;i++) for (let j=0;j<keys.length;j++) if (i!==j){
        const ai=keys[i].split('-').filter(Boolean), aj=keys[j].split('-').filter(Boolean);
        const sub=ai.every(v=>aj.includes(v)) && aj.length>ai.length; if (sub){ rm.add(keys[i]); break; }
      }
      for (const k of rm) m.delete(k);
      return m;
    })();

    // 거리변환 → 대표 라인 선정
    let dist=new cv.Mat(); cv.distanceTransform(eRef2, dist, cv.DIST_L2, 3);
    const linesBest=new Map();
    for (const [key, arr] of clusters.entries()){
      let best=null, bestScore=-1e9;
      for (const idx of arr){
        const line=lines[idx]; const samples=sampleLineVals(dist, line).vals;
        let score=0; for (let k=0;k<samples.length;k++) score+=samples[k];
        if (score>bestScore){ bestScore=score; best=line; }
      }
      const lbls=key.split('-').filter(Boolean).map(Number).sort((a,b)=>a-b);
      for (let i=0;i<lbls.length;i++) for (let j=i+1;j<lbls.length;j++)
        linesBest.set(`${lbls[i]}-${lbls[j]}`, best);
    }

    // 그래프 + 4사이클 → 코너
    const G=buildLabelGraphFromLines(lines, lblMap);
    const cycles=G.cycles;
    function intersectLines2(l1,l2){ const A=abcline(l1), B=abcline(l2); const det=A.a*B.b-B.a*A.b; if (Math.abs(det)<1e-9) return [NaN,NaN]; const x=(A.b*B.c-B.b*A.c)/det, y=(A.c*B.a-B.c*A.a)/det; return [x,y]; }
    const corners=(function(linesBest, cycles){
      const quads=cycles.filter(c=>c.length===4); const corners=[];
      for (const cyc of quads){
        const edges=[[cyc[0],cyc[1]],[cyc[1],cyc[2]],[cyc[2],cyc[3]],[cyc[3],cyc[0]]];
        const used=[]; let ok=true;
        for (const [u,v] of edges){ const key=(Math.min(u,v)+'-'+Math.max(u,v)); const L=linesBest.get(key); if(!L){ ok=false; break; } used.push(L); }
        if (!ok){ corners.push([[NaN,NaN],[NaN,NaN],[NaN,NaN
