<!DOCTYPE html>
<html lang="ko">
<header>
  <div class="title" role="heading" aria-level="1">
    <svg width="28" height="28" viewBox="0 0 24 24" fill="none" aria-hidden="true">
      <path d="M4 5h16v6H4z" stroke="#9fb3ff" stroke-width="1.8"/>
      <path d="M8 15h8m-6 4h4" stroke="#9fb3ff" stroke-width="1.8" stroke-linecap="round"/>
    </svg>
    <h1>이미지 → 반죽 변환기 (아레나 전용)</h1>
  </div>
  <div class="subtitle">
    순서대로 따라만 하세요. <strong>① 이미지 선택 → ② 변환 → ③ 반죽 복사</strong> 끝!
    <br><span aria-label="제작 크레딧">만든이: Starduster</span>
  </div>
</header>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>이미지 → 반죽 변환기 (아레나 전용)</title>
<meta name="color-scheme" content="dark light">
<link rel="stylesheet" href="style.css">

<!-- OpenCV.js: 두 개 CDN 시도 + 런타임 폴링 -->
<script>
(function(){
  let statusEl=null, readyCalled=false, pollId=null;
  function setStatus(t){
    if(!statusEl)statusEl=document.getElementById('status');
    if(statusEl)statusEl.textContent=t;
    const tpl = document.getElementById('tplStatus');  // 추가
    if (tpl) tpl.textContent = t;                      // 추가
  }
  function callReadyOnce(){ if(!readyCalled){ readyCalled=true; if(typeof onCvReady==='function') onCvReady(); } }
  window.onOpenCvLoaded=function(){
    if (typeof cv !== 'undefined'){
      cv['onRuntimeInitialized'] = function(){ callReadyOnce(); };
      let t0=performance.now();
      pollId = setInterval(()=>{
        try{
          if (cv && cv.Mat && typeof cv.imread === 'function'){
            callReadyOnce(); clearInterval(pollId);
          }
          if (performance.now()-t0>10000) clearInterval(pollId);
        }catch(_){}
      },100);
    }
  };
  const urls=['https://docs.opencv.org/4.10.0/opencv.js','https://cdn.jsdelivr.net/npm/opencv.js@4.10.0/dist/opencv.js'];
  let i=0;
  function loadNext(){
    if(i>=urls.length){setStatus('OpenCV.js 로드 실패');return;}
    const u=urls[i++]; setStatus('OpenCV.js 로딩 중… '+u);
    const s=document.createElement('script'); s.src=u; s.async=true;
    s.onload=function(){setStatus('OpenCV.js 스크립트 로드됨'); if(typeof onOpenCvLoaded==='function') onOpenCvLoaded(); };
    s.onerror=function(){setStatus('로드 실패: '+u); loadNext();};
    document.head.appendChild(s);
  }
  loadNext();
  setTimeout(function(){
    if(!(window.cv&&cv.Mat)){ setStatus('초기화 지연: 대체 CDN 시도'); loadNext(); }
  },10000);
})();
</script>

<!-- ONNX Runtime Web -->
<script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
<script>
  // 우선 순위: webgpu -> wasm
  const ORT_EP_ORDER = ['webgpu', 'wasm'];
</script>
</head>

<body>

<main>
  <!-- 1단계: 이미지 선택 -->
  <section class="card fade-in" aria-labelledby="step1">
    <div class="step-title" id="step1">① 이미지 선택</div>
    <p id="fileHint" class="hint">전투 결과 스크린샷 파일을 올리세요. (용병이 꽉 차있지 않으면 실패할 수 있어요)</p>

    <div class="grid" style="margin-top:8px">
      <label for="file" class="sr-only">이미지 파일 선택</label>
      <input id="file" type="file" accept="image/*" aria-describedby="fileHint" />
      <img id="thumb" class="thumb" alt="미리보기 이미지" hidden />
    </div>

    <progress id="tplProgress" max="100" value="0" style="width:100%; margin-top:12px"></progress>
    <div id="tplStatus" class="status" aria-live="polite"></div>
  </section>

  <!-- 2단계: 변환 -->
  <section class="card fade-in" aria-labelledby="step2">
    <div class="step-title" id="step2">② 변환</div>
    <p class="hint">아래 버튼을 누르면 자동으로 분석하고 결과를 만들어 드립니다.</p>
    <div class="actions">
      <button id="run" class="primary" type="button" disabled>변환 시작</button>
      <span id="status" class="status" aria-live="polite"></span>
    </div>
  </section>

  <!-- 3단계: 반죽 결과(아군/적군) -->
  <section class="card fade-in" aria-labelledby="step3">
    <div class="step-title" id="step3">③ 반죽 결과</div>

    <div class="grid" style="margin-top:8px">
      <!-- 아군 -->
      <div>
        <div class="copy-row">
          <span class="hint">아군 반죽</span>
          <button id="copyAllyB64" class="ghost" type="button" aria-label="아군 반죽 복사">복사</button>
          <span id="allyB64Copied" class="status ok" role="status" style="display:none">복사되었습니다!</span>
        </div>
        <textarea id="allyB64" readonly aria-label="아군 반죽"></textarea>
      </div>

      <!-- 적군 -->
      <div>
        <div class="copy-row">
          <span class="hint">적군 반죽</span>
          <button id="copyEnemyB64" class="ghost" type="button" aria-label="적군 반죽 복사">복사</button>
          <span id="enemyB64Copied" class="status ok" role="status" style="display:none">복사되었습니다!</span>
        </div>
        <textarea id="enemyB64" readonly aria-label="적군 반죽"></textarea>
      </div>
    </div>

    <details style="margin-top:12px">
      <summary>로그 자세히 보기</summary>

      <!-- 디버그 미리보기 (접힘) -->
      <div class="preview-wrap" style="margin-top:10px">
        <canvas id="cOrig"  width="800" height="800" aria-label="원본 이미지 미리보기"></canvas>
        <canvas id="cDebug" width="800" height="800" aria-label="탐지 라인 미리보기" style="margin-top:8px"></canvas>
        <canvas id="cAlly"  width="800" height="800" aria-label="아군 영역 워프" style="margin-top:8px"></canvas>
        <canvas id="cEnemy" width="800" height="800" aria-label="적군 영역 워프" style="margin-top:8px"></canvas>
      </div>

      <!-- JSON 결과 + 복사 -->
      <div class="grid" style="margin-top:12px">
        <div>
          <label for="allyJson">아군 JSON</label>
          <div class="copy-row">
            <button id="copyAllyJson" class="ghost" type="button" aria-label="아군 JSON 복사">복사</button>
            <span id="allyJsonCopied" class="status ok" role="status" style="display:none">복사되었습니다!</span>
          </div>
          <textarea id="allyJson" readonly aria-label="아군 JSON 결과"></textarea>
        </div>
        <div>
          <label for="enemyJson">적군 JSON</label>
          <div class="copy-row">
            <button id="copyEnemyJson" class="ghost" type="button" aria-label="적군 JSON 복사">복사</button>
            <span id="enemyJsonCopied" class="status ok" role="status" style="display:none">복사되었습니다!</span>
          </div>
          <textarea id="enemyJson" readonly aria-label="적군 JSON 결과"></textarea>
        </div>
      </div>

      <!-- 진행/로그 -->
      <div style="margin-top:12px">
        <progress id="dbgProgress" max="100" value="0" style="width:100%"></progress>
        <div class="status" id="dbgStep" aria-live="polite"></div>
        <pre id="log" class="hint" style="white-space:pre-wrap"></pre>
      </div>
    </details>
  </section>
</main>

<script>
/* ============== Progress Manager ============== */
const nextFrame = () => new Promise(r=>requestAnimationFrame(()=>r()));
class Progress {
  constructor() {
    this.bar = document.getElementById('bar');
    this.stepText = document.getElementById('stepText');
    this.pctText = document.getElementById('pctText');
    this.elapsedEl = document.getElementById('elapsed');
    this.logEl = document.getElementById('log');
    this.totalWeight = 100;
    this.doneWeight = 0;
    this.startTs = 0;
  }
  start(totalWeight=100){
    this.totalWeight = totalWeight;
    this.doneWeight = 0;
    this.startTs = performance.now();
    this._render(0, '준비 중');
    this._log('--- 시작 ---');
  }
  _render(pct, step){
    this.bar.style.width = `${Math.max(0,Math.min(100,pct))}%`;
    this.pctText.textContent = `${pct.toFixed(0)}%`;
    if (step) this.stepText.textContent = step;
    const elapsed = (performance.now() - this.startTs)/1000;
    this.elapsedEl.textContent = `경과 ${elapsed.toFixed(1)}s`;
  }
  _log(s){ this.logEl.textContent += s + '\n'; this.logEl.parentElement.scrollTop = this.logEl.parentElement.scrollHeight; }
  async step(label, weight, fn){
    const begin = performance.now();
    this._render(this.doneWeight / this.totalWeight * 100, label);
    this._log(`▶ ${label}…`);
    await nextFrame();
    let ret;
    try { ret = await fn(); }
    catch (e) { this._log(`✖ ${label} 실패: ${e.message || e}`); throw e; }
    finally { this._log(`✓ ${label} 완료 (${(performance.now()-begin).toFixed(1)} ms)`); }
    this.doneWeight += weight;
    this._render(this.doneWeight / this.totalWeight * 100, label);
    await nextFrame();
    return ret;
  }
  finish(ok=true, msg='완료'){
    this._render(100, msg);
    this._log(ok? `=== 성공: ${msg} ===` : `=== 종료: ${msg} ===`);
    this.stepText.classList.toggle('error', !ok);
    this.stepText.classList.toggle('success', ok);
  }
}

/* ============== OpenCV Ready Hook ============== */
let cvReady=false, srcMat=null;
function onCvReady(){
  cvReady=true;
  const runEl=document.getElementById('run');
  if (runEl) runEl.disabled=false;
  const st=document.getElementById('status');
  if (st) st.textContent='OpenCV.js 준비 완료';
}

/* ============== Common CV Utils (subset from previous demo) ============== */
function matFromImage(img){ const m=cv.imread(img); let rgb=new cv.Mat(); cv.cvtColor(m,rgb,cv.COLOR_RGBA2RGB); m.delete(); return rgb; }
function toGray(mat){ if (mat.type()===cv.CV_8UC1) return mat.clone(); let g=new cv.Mat(); cv.cvtColor(mat,g,cv.COLOR_RGB2GRAY); return g; }
function drawLinesOn(mat, lines, color=[255,0,0], thickness=2){
  const col = new cv.Scalar(color[0]??255, color[1]??0, color[2]??0, 255);
  const out = mat.clone();
  for (let i=0; i<lines.length; i++){
    const [x1,y1,x2,y2] = lines[i];
    cv.line(out, new cv.Point(x1|0,y1|0), new cv.Point(x2|0,y2|0), col, thickness, cv.LINE_AA);
  }
  return out;
}
function canvasFromMat(mat, canvasOrEl){
  const canvas = (typeof canvasOrEl === 'string')
    ? document.getElementById(canvasOrEl)
    : canvasOrEl;
  if (!canvas) throw new Error('canvas element not found');
  if (canvas.width !== mat.cols || canvas.height !== mat.rows){
    canvas.width  = mat.cols;
    canvas.height = mat.rows;
  }
  cv.imshow(canvas, mat);
}
function makeDbgSlot(title){
  const wrap = document.createElement('div');
  wrap.className = 'slot';
  const h3 = document.createElement('h3'); h3.textContent = title;
  const canvas = document.createElement('canvas');
  canvas.style.width = '100%'; canvas.style.height = 'auto'; canvas.style.display = 'block';
  canvas.style.borderRadius = '8px'; canvas.style.background = '#0b0d10';
  wrap.appendChild(h3); wrap.appendChild(canvas);
  return { wrap, canvas };
}
function percentileGray(mat, perc){
  const images=new cv.MatVector(); images.push_back(mat);
  const channels=[0], mask=new cv.Mat(), hist=new cv.Mat(), histSize=[256], ranges=[0,256];
  cv.calcHist(images, channels, mask, hist, histSize, ranges);
  const total=mat.rows*mat.cols, target=Math.max(0,Math.min(1,perc/100))*total;
  let cum=0, thr=255; for (let i=0;i<256;i++){ cum+=hist.floatAt(i,0); if (cum>=target){thr=i;break;} }
  images.delete(); mask.delete(); hist.delete(); return thr|0;
}
function fastDilateBinary(mask, kSize=3){
  const r = Math.max(1, Math.floor(kSize/2));
  let inv = new cv.Mat(); cv.bitwise_not(mask, inv);
  let dist = new cv.Mat(); cv.distanceTransform(inv, dist, cv.DIST_L2, 3);
  inv.delete();
  let out = new cv.Mat(); cv.threshold(dist, out, r, 255, cv.THRESH_BINARY_INV);
  dist.delete();
  let u8 = new cv.Mat(); out.convertTo(u8, cv.CV_8U); out.delete();
  return u8;
}
function fastErodeBinary(mask, kSize=3){
  const r = Math.max(1, Math.floor(kSize/2));
  let dist = new cv.Mat(); cv.distanceTransform(mask, dist, cv.DIST_L2, 3);
  let out  = new cv.Mat(); cv.threshold(dist, out, r, 255, cv.THRESH_BINARY);
  dist.delete();
  let u8 = new cv.Mat(); out.convertTo(u8, cv.CV_8U); out.delete();
  return u8;
}
function fastOpenBinary(mask, kSize=3){ const er = fastErodeBinary(mask, kSize); const di = fastDilateBinary(er,  kSize); er.delete(); return di; }
function fastCloseBinary(mask, kSize=3){ const di = fastDilateBinary(mask, kSize); const er = fastErodeBinary(di,  kSize); di.delete(); return er; }
function morph(mat, op, kSize=3, iters=1){
  if(op==='dilate') return fastDilateBinary(mat, kSize);
  if(op==='erode')  return fastErodeBinary(mat,  kSize);
  if(op==='open')   return fastOpenBinary(mat,   kSize);
  if(op==='close')  return fastCloseBinary(mat,  kSize);
  throw new Error(`Unknown morph op: ${op}`);
}
function brightnessMask(gray, perc){ const thr=percentileGray(gray, perc); let m=new cv.Mat(); cv.threshold(gray,m,thr,255,cv.THRESH_BINARY); return m; }
/* ===== 라벨 기반 마스크 재구성(고속, 단일 패스) ===== */
function maskFromLabelsSet(labels, keepSet){
  const rows=labels.rows, cols=labels.cols, N=rows*cols;
  const L = labels.data32S;
  let out = new cv.Mat.zeros(rows, cols, cv.CV_8U);
  const M = out.data;
  for (let i=0;i<N;i++){
    const v = L[i];
    if (v>=1 && keepSet.has(v)) M[i]=255;
  }
  return out;
}
function removeSmallComponents(mask, minArea=100, area_w_wh=false){
  let labels=new cv.Mat(), stats=new cv.Mat(), cents=new cv.Mat();
  const n=cv.connectedComponentsWithStats(mask, labels, stats, cents, 4, cv.CV_32S);
  const keep=new Set();
  for (let i=1;i<n;i++){
    const area=stats.intAt(i,cv.CC_STAT_AREA);
    const w=stats.intAt(i,cv.CC_STAT_WIDTH), h=stats.intAt(i,cv.CC_STAT_HEIGHT);
    if ((area_w_wh ? (w*h>=minArea) : (area>=minArea))) keep.add(i);
  }
  const cleaned = (function(labels, keepSet){
    const rows=labels.rows, cols=labels.cols, N=rows*cols;
    const L = labels.data32S;
    let out = new cv.Mat.zeros(rows, cols, cv.CV_8U);
    const M = out.data;
    for (let i=0;i<N;i++){ const v = L[i]; if (v>=1 && keepSet.has(v)) M[i]=255; }
    return out;
  })(labels, keep);
  labels.delete(); stats.delete(); cents.delete();
  return cleaned;
}
function removeThinComponents(mask, minArea=100){
  let labels=new cv.Mat(), stats=new cv.Mat(), cents=new cv.Mat();
  const n=cv.connectedComponentsWithStats(mask, labels, stats, cents, 4, cv.CV_32S);
  const keep=new Set();
  for (let i=1;i<n;i++){
    const area=stats.intAt(i,cv.CC_STAT_AREA);
    const w=stats.intAt(i,cv.CC_STAT_WIDTH), h=stats.intAt(i,cv.CC_STAT_HEIGHT);
    if (area>=minArea && area>0.1*w*h) keep.add(i);
  }
  const cleaned = maskFromLabelsSet(labels, keep);
  labels.delete(); stats.delete(); cents.delete();
  return cleaned;
}
function sampleLineVals(mat, line){
  let [x1,y1,x2,y2]=line.map(v=>Math.round(v));
  const cols=mat.cols, rows=mat.rows, type=mat.type();
  const data8  = (type===cv.CV_8U ) ? mat.data   : null;
  const data32F= (type===cv.CV_32F) ? mat.data32F: null;
  const data32S= (type===cv.CV_32S) ? mat.data32S: null;
  const dx = x2 - x1, dy = y2 - y1;
  const steps = Math.max(Math.abs(dx), Math.abs(dy)) || 1;
  const sx = dx / steps, sy = dy / steps;
  let x = x1, y = y1; const vals = [];
  for (let i=0;i<=steps;i++){
    const xi = x|0, yi = y|0;
    if (xi>=0 && xi<cols && yi>=0 && yi<rows){
      const idx = yi*cols + xi; let v=0;
      if (data8)   v = data8[idx];
      else if (data32F) v = data32F[idx];
      else if (data32S) v = data32S[idx];
      else v = mat.ucharAt(yi,xi);
      vals.push(v);
    }
    x += sx; y += sy;
  }
  return { vals };
}
function countIntersectionsByPaint(lines, brushSize, angleDeg, imgShape){
  const [H, W] = imgShape; const N = lines.length | 0; const eps = 1e-9;
  const angleThr = (angleDeg * Math.PI/180) || (30 * Math.PI/180);
  const rBase = Math.max(1, brushSize | 0);
  function ang(l){ return Math.atan2(l[3]-l[1], l[2]-l[0]); }
  function intersect(l1,l2){
    const [x1,y1,x2,y2]=l1, [x3,y3,x4,y4]=l2;
    const den=(x2-x1)*(y4-y3)-(y2-y1)*(x4-x3);
    if (Math.abs(den) < eps) return null;
    const t=((x3-x1)*(y4-y3)-(y3-y1)*(x4-x3))/den;
    return [x1 + t*(x2-x1), y1 + t*(y2-y1)];
  }
  const mask = new cv.Mat.zeros(H, W, cv.CV_8U);
  const angles = new Array(N); for (let i=0;i<N;i++) angles[i] = ang(lines[i]);
  for (let i=0;i<N;i++){
    const ai = angles[i], li = lines[i];
    for (let j=i+1;j<N;j++){
      let d = Math.abs(ai - angles[j]); if (d > Math.PI) d = 2*Math.PI - d;
      if (d + 1e-9 < angleThr) continue;
      const P = intersect(li, lines[j]); if (!P) continue;
      const cx = Math.round(P[0]), cy = Math.round(P[1]);
      const dx = (cx < 0) ? -cx : (cx > (W-1) ? (cx-(W-1)) : 0);
      const dy = (cy < 0) ? -cy : (cy > (H-1) ? (cy-(H-1)) : 0);
      const overflow = Math.max(dx, dy);
      const cap = Math.min(Math.floor(Math.max(H, W) / 20), 48);
      const r = rBase + Math.min(overflow * 3, cap);
      cv.circle(mask, new cv.Point(cx, cy), r|0, new cv.Scalar(255,255,255,255), -1);
    }
  }
  let labels=new cv.Mat(), stats=new cv.Mat(), cents=new cv.Mat();
  const n = cv.connectedComponentsWithStats(mask, labels, stats, cents, 4, cv.CV_32S);
  mask.delete(); stats.delete(); cents.delete();
  return { count: Math.max(n-1,0), labels };
}
function buildLabelGraphFromLines(lines, labels){
  function edgeKey(a,b){ return a<b ? (a+'-'+b) : (b+'-'+a); }
  const adj=new Map(); const edges=new Map();
  function addEdge(a,b){
    if (!adj.has(a)) adj.set(a,new Set());
    if (!adj.has(b)) adj.set(b,new Set());
    adj.get(a).add(b); adj.get(b).add(a);
    edges.set(edgeKey(a,b), true);
  }
  for (let idx=0; idx<lines.length; idx++){
    const {vals}=sampleLineVals(labels, lines[idx]); const seq=vals.map(v=>v|0).filter(v=>v>=1);
    if (seq.length<2) continue;
    const uniq=[]; for(let k=0;k<seq.length;k++){ if (k===0 || seq[k]!==seq[k-1]) uniq.push(seq[k]); }
    for (let k=0;k<uniq.length-1;k++){
      const a=uniq[k], b=uniq[k+1]; if (a===b) continue; addEdge(a,b);
    }
  }
  const cycles=new Set();
  const norm=(cyc)=>{
    const r=cyc.slice(); const m=Math.min(...r); const i=r.indexOf(m);
    const rot=r.slice(i).concat(r.slice(0,i));
    const rev=[rot[0],rot[3],rot[2],rot[1]];
    const a=rot.join('-'), b=rev.join('-');
    return a<b? a : b;
  };
  for (const u of adj.keys()){
    for (const v of (adj.get(u)||new Set()).keys()) if (v>u){
      for (const x of (adj.get(u)||new Set()).keys()) if (x>u && x!==v){
        for (const y of (adj.get(v)||new Set()).keys()) if (y>v && y!==u){
          if ((adj.get(x)||new Set()).has(y)) cycles.add(norm([u,v,y,x]));
        }
      }
    }
  }
  return { cycles:[...cycles].map(s=>s.split('-').map(Number)) , adj, edges };
}
function abcline(line){ const [x1,y1,x2,y2]=line.map(Number); const dx=x2-x1, dy=y2-y1; const a=dy,b=-dx,c=-(a*x1+b*y1); return {a,b,c}; }
function intersectLines(l1,l2){ const A=abcline(l1), B=abcline(l2); const det=A.a*B.b-B.a*A.b; if (Math.abs(det)<1e-9) return [NaN,NaN]; const x=(A.b*B.c-B.b*A.c)/det, y=(A.c*B.a-B.c*A.a)/det; return [x,y]; }
function cornersFromCycles(linesBest, cycles){
  const quads=cycles.filter(c=>c.length===4); const corners=[];
  for (const cyc of quads){
    const edges=[[cyc[0],cyc[1]],[cyc[1],cyc[2]],[cyc[2],cyc[3]],[cyc[3],cyc[0]]];
    const lines=[]; let ok=true;
    for (const [u,v] of edges){ const key=(Math.min(u,v)+'-'+Math.max(u,v)); if (!linesBest.has(key)){ ok=false; break; } lines.push(linesBest.get(key)); }
    if (!ok){ corners.push([[NaN,NaN],[NaN,NaN],[NaN,NaN],[NaN,NaN]]); continue; }
    corners.push([
      intersectLines(lines[3],lines[0]),
      intersectLines(lines[0],lines[1]),
      intersectLines(lines[1],lines[2]),
      intersectLines(lines[2],lines[3]),
    ]);
  }
  return corners;
}
function polygonArea(pts){ if (pts.some(p=>!isFinite(p[0])||!isFinite(p[1]))) return 0; let s=0; for (let i=0;i<pts.length;i++){ const [x1,y1]=pts[i],[x2,y2]=pts[(i+1)%pts.length]; s+=x1*y2 - y1*x2; } return Math.abs(0.5*s); }
function orderCornersTLTRBRBL(pts){
  const arr = pts.map(p => ({ p, s: p[0] + p[1], d: p[0] - p[1] }));
  const tl = arr.reduce((a,b) => a.s < b.s ? a : b).p;
  const br = arr.reduce((a,b) => a.s > b.s ? a : b).p;
  const tr = arr.reduce((a,b) => a.d > b.d ? a : b).p;
  const bl = arr.reduce((a,b) => a.d < b.d ? a : b).p;
  return [tl,tr,br,bl];
}
function normalizeForView(mat32f){ const mm=cv.minMaxLoc(mat32f); let out=new cv.Mat(); const scale=(mm.maxVal>0? 255.0/mm.maxVal : 1.0); mat32f.convertTo(out, cv.CV_8U, scale, 0); return out; }
function labelToColor(labels){
  let lab32f = new cv.Mat(); labels.convertTo(lab32f, cv.CV_32F);
  const mm = cv.minMaxLoc(lab32f); lab32f.delete();
  let val8 = new cv.Mat(); const scale = mm.maxVal > 0 ? 255.0 / mm.maxVal : 1.0;
  labels.convertTo(val8, cv.CV_8U, scale, 0);
  let R = val8.clone();
  let G = new cv.Mat(val8.rows, val8.cols, cv.CV_8U, new cv.Scalar(0));
  let S255 = new cv.Mat(val8.rows, val8.cols, cv.CV_8U, new cv.Scalar(255));
  cv.subtract(S255, val8, G);
  let B = new cv.Mat(val8.rows, val8.cols, cv.CV_8U, new cv.Scalar(0));
  let S128 = new cv.Mat(val8.rows, val8.cols, cv.CV_8U, new cv.Scalar(128));
  cv.absdiff(val8, S128, B);
  let mv = new cv.MatVector(); mv.push_back(B); mv.push_back(G); mv.push_back(R);
  let out = new cv.Mat(); cv.merge(mv, out);
  mv.delete(); B.delete(); G.delete(); R.delete(); S128.delete(); S255.delete(); val8.delete();
  return out;
}

function idKey(i,j){ return String(parseInt(`${i}${j}`,10)); } // Python과 동일 키(“01”→“1”)

/* ============== Detect + Recognize (warps & patches) ============== */
async function detectAndRecognize(imgRGB, opts, progress){
  const H=imgRGB.rows, W=imgRGB.cols; const dbg=[];
  progress.start(100);

  const gray = await progress.step('Grayscale', 2, async ()=> toGray(imgRGB));

  const e_log = await progress.step('LoG edges', 6, async ()=>{
    let lap=new cv.Mat(); cv.Laplacian(gray,lap,cv.CV_16S,3,1,0,cv.BORDER_DEFAULT);
    let lapAbs=new cv.Mat(); cv.convertScaleAbs(lap,lapAbs); lap.delete();
    let thr=percentileGray(lapAbs,75); let bw=new cv.Mat(); cv.threshold(lapAbs,bw,thr,255,cv.THRESH_BINARY); lapAbs.delete();
    dbg.push(['LoG edges', bw.clone()]);
    return bw;
  });

  const flatRefined = await progress.step('Morph + flat refine (fast)', 16, async ()=>{
    const e_close = morph(e_log,'close',3,1);
    let flat = new cv.Mat(); cv.bitwise_not(e_close, flat); e_close.delete();

    const minAreaThin = (H*W/2000)|0;
    let flat2 = removeThinComponents(flat, minAreaThin); flat.delete();

    const ksize = (Math.max(H,W)/200)|0;
    const flatDil = morph(flat2,'dilate',Math.max(1,ksize),1);
    let flatNei = new cv.Mat(); cv.bitwise_xor(flatDil, flat2, flatNei); flatDil.delete();

    const bmask75 = brightnessMask(gray,75);
    let invB = new cv.Mat(); cv.bitwise_not(bmask75, invB);
    let flatNeiDark = new cv.Mat(); cv.bitwise_and(flatNei, invB, flatNeiDark); invB.delete();

    let flat3 = new cv.Mat(); cv.bitwise_or(flat2, flatNeiDark, flat3);
    flatNeiDark.delete(); flat2.delete();
    const flatClean = removeThinComponents(flat3, (H*W/50)|0); flat3.delete();

    let invFlat = new cv.Mat(); cv.bitwise_not(flatClean, invFlat);
    let labels = new cv.Mat(), stats = new cv.Mat(), cents = new cv.Mat();
    const ncc = cv.connectedComponentsWithStats(invFlat, labels, stats, cents, 4, cv.CV_32S);
    const areas = []; for (let i=1;i<ncc;i++) areas.push({i, area:stats.intAt(i,cv.CC_STAT_AREA)});
    areas.sort((a,b)=>a.area-b.area);
    const top2 = new Set(areas.slice(-2).map(o=>o.i));
    const maskTop2 = maskFromLabelsSet(labels, top2);

    let flatRefined = new cv.Mat(); cv.bitwise_not(maskTop2, flatRefined);
    labels.delete(); stats.delete(); cents.delete(); maskTop2.delete(); invFlat.delete();

    dbg.push(['flat_refined_cc', flatRefined.clone()]);
    return flatRefined;
  });

  const bandAndLines = await progress.step('Band & Lines', 12, async ()=>{
    const H = imgRGB.rows, W = imgRGB.cols;

    const ksize = (Math.max(H, W) / 200) | 0;
    const bmask75 = brightnessMask(gray, 75);

    const flatKsize = Math.max(2 * ksize, 1);
    const flatDil2 = fastDilateBinary(flatRefined, flatKsize);
    let flatNei2 = new cv.Mat(); cv.bitwise_xor(flatDil2, flatRefined, flatNei2); flatDil2.delete();
    dbg.push(['flat_neighbor', flatNei2.clone()]);

    const bmaskKsize = Math.max(6 * ksize, 1);
    const bmaskDil = fastDilateBinary(bmask75, bmaskKsize);

    let eRef = new cv.Mat(); cv.bitwise_and(flatNei2, bmaskDil, eRef);
    flatNei2.delete(); bmaskDil.delete();

    eRef = morph(eRef, 'open', Math.max((ksize / 2) | 0, 1), 1);
    const eRefClean = removeSmallComponents(eRef, (H * W / 20) | 0, true); eRef.delete();

    let eRef2 = new cv.Mat(); cv.bitwise_and(eRefClean, bmask75, eRef2); eRefClean.delete();
    dbg.push(['log_refined', eRef2.clone()]);

    const scale = 0.5;
    let small = new cv.Mat(); cv.resize(eRef2, small, new cv.Size(0,0), scale, scale, cv.INTER_NEAREST);

    let linesP = new cv.Mat();
    cv.HoughLinesP(
      small, linesP,
      1.0, Math.PI/720,
      Math.max(H, W) / 16 | 0,
      (Math.max(H, W) / 12 | 0) * scale,
      (Math.max(H, W) / 12 | 0) * scale
    );
    const lines = [];
    for (let i=0;i<linesP.rows;i++){
      lines.push([
        (linesP.intAt(i,0) / scale) | 0,
        (linesP.intAt(i,1) / scale) | 0,
        (linesP.intAt(i,2) / scale) | 0,
        (linesP.intAt(i,3) / scale) | 0
      ]);
    }
    linesP.delete(); small.delete();

    dbg.push(['hough', drawLinesOn(imgRGB, lines, [255,128,0], 2)]);

    const inter = countIntersectionsByPaint(lines, opts.brush | 0, opts.angleDeg | 0, [H, W]);
    dbg.push(['intersection_map', labelToColor(inter.labels)]);

    return { eRef2, lines, lblMap: inter.labels };
  });

  const { eRef2, lines, lblMap } = bandAndLines;

  const warpRes = await progress.step('Cluster/Graph/Corners & Warp', 52, async ()=>{
    // 클러스터
    const clusters=(function(){
      const m = new Map();
      for(let idx=0; idx<lines.length; idx++){
        const {vals}=sampleLineVals(lblMap, lines[idx]); const s=new Set();
        for (const v of vals){ if ((v|0)>=1) s.add(v|0); }
        const key=[...s].sort((a,b)=>a-b).join('-');
        if (!m.has(key)) m.set(key, []);
        m.get(key).push(idx);
      }
      const keys=[...m.keys()], rm=new Set();
      for (let i=0;i<keys.length;i++) for (let j=0;j<keys.length;j++) if (i!==j){
        const ai=keys[i].split('-').filter(Boolean), aj=keys[j].split('-').filter(Boolean);
        const sub=ai.every(v=>aj.includes(v)) && aj.length>ai.length; if (sub){ rm.add(keys[i]); break; }
      }
      for (const k of rm) m.delete(k);
      return m;
    })();

    // 시각화
    const palette=[...Array(30)].map(()=>[40+Math.random()*215|0,40+Math.random()*215|0,40+Math.random()*215|0]);
    let imgVis=imgRGB.clone(); let ci=0;
    for (const [,arr] of clusters.entries()){ const ls=arr.map(i=>lines[i]); imgVis=drawLinesOn(imgVis, ls, palette[ci%palette.length], 3); ci++; }
    dbg.push(['cluster', imgVis]);

    // 거리변환 → 베스트 라인
    let dist=new cv.Mat(); cv.distanceTransform(eRef2, dist, cv.DIST_L2, 3);
    dbg.push(['e_log_dist', normalizeForView(dist)]);
    const linesBest=new Map();
    for (const [key, arr] of clusters.entries()){
      let best=null, bestScore=-1e9;
      for (const idx of arr){
        const line=lines[idx]; const samples=sampleLineVals(dist, line).vals;
        let score=0; for (let k=0;k<samples.length;k++) score+=samples[k];
        if (score>bestScore){ bestScore=score; best=line; }
      }
      const lbls=key.split('-').filter(Boolean).map(Number).sort((a,b)=>a-b);
      for (let i=0;i<lbls.length;i++) for (let j=i+1;j<lbls.length;j++)
        linesBest.set(`${lbls[i]}-${lbls[j]}`, best);
    }

    // 그래프 + 4사이클
    const G=buildLabelGraphFromLines(lines, lblMap);
    const cycles=G.cycles;

    // 코너
    const C=cornersFromCycles(linesBest, cycles);
    let bestQuad=null, bestArea=0; for (const c of C){ const a=polygonArea(c); if (a>bestArea){bestArea=a; bestQuad=c;} }
    if (!bestQuad){ dist.delete(); return { ordered:null }; }
    let ordered=orderCornersTLTRBRBL(bestQuad);

    // ===== recognize_formations (JS 포팅, Z=0 근사) =====
    const sizeFull=opts.sizeFull|0, sizePatch=opts.sizePatch|0;

    // 월드 정의 (Python World와 동일 값)
    const borderLen = 1.0;
    const marginAE  = 0.125*borderLen;
    const marginBL  = 0.06*borderLen;
    const nGrid     = 7;
    const heightTroop = 0.045 * borderLen;
    const heightHero  = 0.09  * borderLen;

    // 경계(월드) 사각형
    const allyBorder = [[0,0],[borderLen,0],[borderLen,borderLen],[0,borderLen]];
    const enemyBorder= [[0,-marginAE-borderLen],[borderLen,-marginAE-borderLen],[borderLen,-marginAE],[0,-marginAE]];

    // 내부(마진 적용) 사각형
    const marginVec = [[-marginBL,-marginBL],[ marginBL,-marginBL],[ marginBL, marginBL],[-marginBL, marginBL]];
    const allyInner = allyBorder.map((p,idx)=>[p[0]-marginVec[idx][0], p[1]-marginVec[idx][1]]);
    const enemyInner = enemyBorder.map((p,idx)=>[p[0]-marginVec[idx][0], p[1]-marginVec[idx][1]]);

    const formLen = 1 - 2*marginBL;
    const cell    = formLen / nGrid;

    /* ===== 3x3 행렬 유틸 ===== */
    function matMul3x3(A, B){
      const C = [[0,0,0],[0,0,0],[0,0,0]];
      for (let i=0;i<3;i++)
        for (let j=0;j<3;j++)
          C[i][j] = A[i][0]*B[0][j] + A[i][1]*B[1][j] + A[i][2]*B[2][j];
      return C;
    }
    function matInv3x3(M){
      const m = M.flat();
      const a=m[0], b=m[1], c=m[2], d=m[3], e=m[4], f=m[5], g=m[6], h=m[7], i=m[8];
      const A = e*i - f*h, B = -(d*i - f*g), C = d*h - e*g;
      const D = -(b*i - c*h), E = a*i - c*g, F = -(a*h - b*g);
      const G = b*f - c*e, H = -(a*f - c*d), I = a*e - b*d;
      const det = a*A + b*B + c*C;
      const invDet = 1.0 / det;
      return [
        [A*invDet, D*invDet, G*invDet],
        [B*invDet, E*invDet, H*invDet],
        [C*invDet, F*invDet, I*invDet]
      ];
    }
    function toCv64F(M){
      return cv.matFromArray(3,3,cv.CV_64F, [M[0][0],M[0][1],M[0][2], M[1][0],M[1][1],M[1][2], M[2][0],M[2][1],M[2][2]]);
    }
    
    /* ===== 카메라 K (Python과 동일 가정: f=min(w,h), cx=w/2, cy=h/2) ===== */
    function makeK(w,h){
      const f = Math.min(w,h);
      return [[f,0,w*0.5],[0,f,h*0.5],[0,0,1]];
    }
    
    /* ===== H0 분해 → 높이 h의 평면 호모그래피 H(h) ===== */
    function decomposeH0_getHh(H0, w, h){
      // cv.Mat(3x3) → 2D 배열
      const H = [
        [H0.doubleAt(0,0), H0.doubleAt(0,1), H0.doubleAt(0,2)],
        [H0.doubleAt(1,0), H0.doubleAt(1,1), H0.doubleAt(1,2)],
        [H0.doubleAt(2,0), H0.doubleAt(2,1), H0.doubleAt(2,2)]
      ];
      const K    = makeK(w,h);
      const Kinv = matInv3x3(K);
    
      // B = K^-1 H0 = [b1 b2 b3]
      const B = matMul3x3(Kinv, H);
      const b1 = [B[0][0],B[1][0],B[2][0]];
      const b2 = [B[0][1],B[1][1],B[2][1]];
      const b3 = [B[0][2],B[1][2],B[2][2]];
    
      const lam = 1.0 / Math.hypot(b1[0], b1[1], b1[2]);
      const r1 = b1.map(v=>lam*v);
      const r2 = b2.map(v=>lam*v);
      const r3 = [
        r1[1]*r2[2]-r1[2]*r2[1],
        r1[2]*r2[0]-r1[0]*r2[2],
        r1[0]*r2[1]-r1[1]*r2[0]
      ];
      const t  = b3.map(v=>lam*v);
    
      function getHh(height){
        const col1 = r1, col2 = r2, col3 = [ t[0]-height*r3[0], t[1]-height*r3[1], t[2]-height*r3[2] ];
        const Rt = [[col1[0],col2[0],col3[0]],
                    [col1[1],col2[1],col3[1]],
                    [col1[2],col2[2],col3[2]]];
        const KH = matMul3x3(K, Rt);
        return toCv64F(KH); // cv.Mat 3x3 CV_64F
      }
      return { getHh };
    }

    // 퍼스펙티브 변환/프로젝션 유틸
    function getPerspectiveTransformFromPts(srcPts, dstPts){
      const src=cv.matFromArray(4,1,cv.CV_32FC2, srcPts.flat());
      const dst=cv.matFromArray(4,1,cv.CV_32FC2, dstPts.flat());
      const H=cv.getPerspectiveTransform(src,dst); src.delete(); dst.delete(); return H;
    }
    function projectQuad(H, quad){
      const src=cv.matFromArray(4,1,cv.CV_32FC2, quad.flat()); let out=new cv.Mat();
      cv.perspectiveTransform(src,out,H); const arr=[]; for (let i=0;i<4;i++) arr.push([out.floatAt(i,0), out.floatAt(i,1)]);
      src.delete(); out.delete(); return arr;
    }
    function warpByPts(img, srcPts, size){
      const dstPts=[[0,0],[size-1,0],[size-1,size-1],[0,size-1]];
      const H=getPerspectiveTransformFromPts(srcPts,dstPts); let warped=new cv.Mat();
      cv.warpPerspective(img,warped,H,new cv.Size(size,size),cv.INTER_LINEAR,cv.BORDER_REPLICATE); H.delete(); return warped;
    }

    // H0: (월드 allyBorder → 이미지 사각형 ordered)
    const H0=getPerspectiveTransformFromPts(allyBorder, ordered);

    // H(h) 생성 (Troop/Hero용) — Python의 compute_plane_transform 분해식
    const { getHh } = decomposeH0_getHh(H0, imgRGB.cols, imgRGB.rows);
    const Hh_troop = getHh(heightTroop);
    const Hh_hero  = getHh(heightHero);

    // Ally/Enemy 전체 워프
    const allyInImg  = projectQuad(H0, allyBorder);
    const enemyInImg = projectQuad(H0, enemyBorder);
    const allyWarp   = warpByPts(imgRGB, allyInImg, sizeFull);
    const enemyWarp  = warpByPts(imgRGB, enemyInImg, sizeFull);

    // 셀 사각형 생성기 (월드 좌표 → 이미지 워프)
    function gridQuadAlly(i,j){
      const x0 = allyInner[0][0] + j*cell;
      const y0 = allyInner[0][1] + i*cell;
      return [[x0,y0],[x0+cell,y0],[x0+cell,y0+cell],[x0,y0+cell]];
    }
    function gridQuadEnemy(i,j){
      // 원 코드와 동일한 방향(오른→왼, 아래→위) 기준: inner[2]는 br
      const x0 = enemyInner[2][0] - (j+1)*cell;
      const y0 = enemyInner[2][1] - (i+1)*cell;
      return [[x0,y0],[x0+cell,y0],[x0+cell,y0+cell],[x0,y0+cell]];
    }

    // Troops (7x7): 반드시 Hh_troop 사용
    const troopsAlly = {}, troopsEnemy = {};
    for (let i=0;i<nGrid;i++){
      for (let j=0;j<nGrid;j++){
        const qa = projectQuad(Hh_troop, gridQuadAlly(i,j));
        const wa = warpByPts(imgRGB, qa, sizePatch);
        troopsAlly[idKey(i,j)] = wa;
    
        const qe = projectQuad(Hh_troop, gridQuadEnemy(i,j));
        const we = warpByPts(imgRGB, qe, sizePatch);
        troopsEnemy[idKey(i,j)] = we;
      }
    }
    
    // Heroes (3): 반드시 Hh_hero 사용
    const heroesAlly = {}, heroesEnemy = {};
    const hjAlly = [[0,[7,3]],[1,[3,-1]],[2,[3,7]]];
    const hjEnemy= [[0,[7,3]],[1,[3.5,-1]],[2,[3.5,7]]];
    
    for (const [k,[ii,jj]] of hjAlly){
      const qa = projectQuad(Hh_hero, gridQuadAlly(ii, jj));
      const wa = warpByPts(imgRGB, qa, sizePatch);
      heroesAlly[String(k)] = wa;
    }
    for (const [k,[ii,jj]] of hjEnemy){
      const qe = projectQuad(Hh_hero, gridQuadEnemy(ii, jj));
      const we = warpByPts(imgRGB, qe, sizePatch);
      heroesEnemy[String(k)] = we;
    }

    H0.delete(); Hh_troop.delete(); Hh_hero.delete();
    return { ordered, allyWarp, enemyWarp, troopsAlly, troopsEnemy, heroesAlly, heroesEnemy };
  });

  // 리소스 정리
  e_log.delete(); flatRefined.delete(); bandAndLines.eRef2.delete(); bandAndLines.lblMap.delete();

  return {
    corners: warpRes.ordered,
    ally: warpRes.allyWarp, enemy: warpRes.enemyWarp,
    troopsAlly: warpRes.troopsAlly, troopsEnemy: warpRes.troopsEnemy,
    heroesAlly: warpRes.heroesAlly, heroesEnemy: warpRes.heroesEnemy,
    dbg
  };
}

/* ============== ONNX Runtime Web: Model & Inference ============== */
const IMG_W = 32, IMG_H = 32;
const MEAN = [0.5, 0.5, 0.5];
const STD  = [0.5, 0.5, 0.5];

let troopSession = null, idxToLabel = null;

async function loadTroopModel() {
  if (!troopSession) {
    troopSession = await ort.InferenceSession.create('assets/troops_smallcnn.onnx', {
      executionProviders: ORT_EP_ORDER,
      graphOptimizationLevel: 'all',
    });
  }
  if (!idxToLabel) {
    const res = await fetch('assets/troop_idx_to_label.json');
    idxToLabel = await res.json(); // {"0":"101","1":"102",...}
  }
  return { troopSession, idxToLabel };
}

// cv.Mat(RGB, HxW, CV_8UC3) -> Float32Array (CHW), Normalize
function matToNCHWFloat32(mat) {
  let resized = mat;
  if (mat.cols !== IMG_W || mat.rows !== IMG_H) {
    resized = new cv.Mat();
    cv.resize(mat, resized, new cv.Size(IMG_W, IMG_H), 0, 0, cv.INTER_LINEAR);
  }
  const hwc = resized.data; // Uint8Array
  const n = IMG_W * IMG_H;
  const chw = new Float32Array(3 * n);
  for (let i = 0; i < n; i++) {
    const r = hwc[i * 3 + 0] / 255;
    const g = hwc[i * 3 + 1] / 255;
    const b = hwc[i * 3 + 2] / 255;
    chw[0 * n + i] = (r - MEAN[0]) / STD[0];
    chw[1 * n + i] = (g - MEAN[1]) / STD[1];
    chw[2 * n + i] = (b - MEAN[2]) / STD[2];
  }
  if (resized !== mat) resized.delete();
  return chw;
}
function buildBatchTensor(mats) {
  const n = mats.length;
  const nchw = new Float32Array(n * 3 * IMG_H * IMG_W);
  const stride = 3 * IMG_H * IMG_W;
  for (let bi = 0; bi < n; bi++) {
    const chw = matToNCHWFloat32(mats[bi]);
    nchw.set(chw, bi * stride);
  }
  return new ort.Tensor('float32', nchw, [n, 3, IMG_H, IMG_W]);
}
async function inferTroopsFromMats(patchMats) {
  await loadTroopModel();
  if (patchMats.length === 0) return [];
  const inputTensor = buildBatchTensor(patchMats);
  const out = await troopSession.run({ images: inputTensor });
  const logits = out.logits.data;   // Float32Array (N * C)
  const C = out.logits.dims[1];
  const N = out.logits.dims[0];

  const results = [];
  for (let i = 0; i < N; i++) {
    let maxIdx = 0, maxVal = -1e9, sumExp = 0;
    const tmp = new Float32Array(C);
    for (let c = 0; c < C; c++) {
      const v = logits[i * C + c];
      tmp[c] = Math.exp(v);
      sumExp += tmp[c];
      if (v > maxVal) { maxVal = v; maxIdx = c; }
    }
    const prob = tmp[maxIdx] / sumExp;
    const labelStr = idxToLabel[String(maxIdx)];
    results.push({ idx: maxIdx, label: labelStr, prob });
  }
  return results;
}

/* ============== UI Bindings ============== */
/* ====== 고정 옵션 (이전 숫자 입력값 대체) ====== */
const FIXED_OPTS = {
  angleDeg: 45,
  brush: 5,
  sizeFull: 1024,
  sizePatch: 32
};

/* ====== 썸네일 및 파일 로드 ====== */
const fileInput = document.getElementById('file');
const thumb = document.getElementById('thumb');
fileInput.addEventListener('change', e => {
  const f = e.target.files?.[0]; if (!f) return;
  const img = new Image();
  img.onload = () => {
    if (srcMat) srcMat.delete();
    srcMat = matFromImage(img);
    // 썸네일 표시
    thumb.hidden = false;
    const scale = Math.min(240 / img.width, 240 / img.height, 1);
    const cvs = document.createElement('canvas');
    cvs.width = Math.round(img.width * scale);
    cvs.height = Math.round(img.height * scale);
    const ctx = cvs.getContext('2d');
    ctx.drawImage(img, 0, 0, cvs.width, cvs.height);
    thumb.src = cvs.toDataURL('image/png');

    // 원본 캔버스(접힌 영역)도 갱신
    const cOrig = document.getElementById('cOrig');
    cOrig.width = srcMat.cols; cOrig.height = srcMat.rows;
    canvasFromMat(srcMat, cOrig);

    // 실행 버튼 활성화
    const runBtn = document.getElementById('run');
    if (cv && cv.Mat) runBtn.disabled = false;
  };
  img.src = URL.createObjectURL(f);
});

/* ====== 복사 유틸 ====== */
async function copyTextToClipboard(text, okEl) {
  try {
    await navigator.clipboard.writeText(text);
    okEl.style.display = '';
    setTimeout(() => { okEl.style.display = 'none'; }, 1200);
  } catch (e) {
    alert('복사 실패: ' + (e?.message || e));
  }
}
document.getElementById('copyAllyB64').addEventListener('click', () => {
  copyTextToClipboard(document.getElementById('allyB64').value, document.getElementById('allyB64Copied'));
});
document.getElementById('copyEnemyB64').addEventListener('click', () => {
  copyTextToClipboard(document.getElementById('enemyB64').value, document.getElementById('enemyB64Copied'));
});
document.getElementById('copyAllyJson').addEventListener('click', () => {
  copyTextToClipboard(document.getElementById('allyJson').value, document.getElementById('allyJsonCopied'));
});
document.getElementById('copyEnemyJson').addEventListener('click', () => {
  copyTextToClipboard(document.getElementById('enemyJson').value, document.getElementById('enemyJsonCopied'));
});

/* ====== 진행 표시 (접힌 영역용, 간단 바인딩) ====== */
const dbgProgress = document.getElementById('dbgProgress');
const dbgStep = document.getElementById('dbgStep');
const oldProgressStep = Progress.prototype.step;
Progress.prototype.step = async function(label, weight, fn){
  dbgStep.textContent = label;
  const v = Math.round((this.doneWeight / Math.max(1, this.totalWeight)) * 100);
  dbgProgress.value = v;
  return await oldProgressStep.call(this, label, weight, fn);
};
const oldFinish = Progress.prototype.finish;
Progress.prototype.finish = function(ok=true, msg='완료'){
  dbgProgress.value = 100;
  dbgStep.textContent = msg;
  return oldFinish.call(this, ok, msg);
};

/* ====== 실행 버튼 ====== */
document.getElementById('run').addEventListener('click', async () => {
  const runBtn = document.getElementById('run');
  const st = document.getElementById('status');
  if (!cvReady) { alert('OpenCV 초기화 전입니다. 잠시 후 다시 시도하세요.'); return; }
  if (!srcMat) { alert('이미지를 선택하세요.'); return; }

  runBtn.disabled = true;
  st.textContent = '실행 중…';

  // 진행/로그 초기화
  document.getElementById('log').textContent = '';
  dbgProgress.value = 0; dbgStep.textContent = '준비 중';

  const progress = new Progress();

  try {
    // 1) Detect & Recognize
    const res = await detectAndRecognize(srcMat, FIXED_OPTS, progress);

    // 2) 디버그 캔버스 (접힌 영역)
    if (res.ally){ const cA=document.getElementById('cAlly'); cA.width=res.ally.cols; cA.height=res.ally.rows; canvasFromMat(res.ally,cA); res.ally.delete(); }
    if (res.enemy){ const cE=document.getElementById('cEnemy'); cE.width=res.enemy.cols; cE.height=res.enemy.rows; canvasFromMat(res.enemy,cE); res.enemy.delete(); }

    // 3) ONNX 추론
    await progress.step('모델 로드', 5, async ()=>{ await loadTroopModel(); });
    // 기존 inferTroopsFromMats 호출은 detectAndRecognize 내부의 patch 수집 결과를 써야합니다.
    // (패치 보드는 노출을 없앴지만, 내부 로직은 동일)
    const allyKeys = [], allyMats = [];
    const enemyKeys = [], enemyMats = [];
    for (let i=0;i<7;i++){
      for (let j=0;j<7;j++){
        const key = idKey(i,j);
        const A = res.troopsAlly[key], E = res.troopsEnemy[key];
        if (A){ allyKeys.push(key); allyMats.push(A); }
        if (E){ enemyKeys.push(key); enemyMats.push(E); }
      }
    }
    const allyRes  = await progress.step('아군 추론', 3, async ()=> await inferTroopsFromMats(allyMats));
    const enemyRes = await progress.step('적군 추론', 3, async ()=> await inferTroopsFromMats(enemyMats));

    // 4) JSON 구성
    const troopLayoutAlly = {}, probsAlly = {};
    for (let i=0;i<allyKeys.length;i++){ troopLayoutAlly[allyKeys[i]] = Number(allyRes[i].label); probsAlly[allyKeys[i]] = Number(allyRes[i].prob.toFixed(6)); }
    const troopLayoutEnemy = {}, probsEnemy = {};
    for (let i=0;i<enemyKeys.length;i++){ troopLayoutEnemy[enemyKeys[i]] = Number(enemyRes[i].label); probsEnemy[enemyKeys[i]] = Number(enemyRes[i].prob.toFixed(6)); }
    allyMats.forEach(m=>m.delete()); enemyMats.forEach(m=>m.delete());

    const ally_json = { GameMode: 0, troopLayout: troopLayoutAlly, heroLayout: {}, armyLayout: null, meta: { probs: probsAlly } };
    const enemy_json = { GameMode: 0, troopLayout: troopLayoutEnemy, heroLayout: {}, armyLayout: null, meta: { probs: probsEnemy } };

    // 5) 반죽(Base64) 및 JSON 채우기
    const allyStr  = JSON.stringify(ally_json);
    const enemyStr = JSON.stringify(enemy_json);
    document.getElementById('allyJson').value  = allyStr;
    document.getElementById('enemyJson').value = enemyStr;

    const allyB64 = btoa(unescape(encodeURIComponent(allyStr)));
    const enemyB64 = btoa(unescape(encodeURIComponent(enemyStr)));
    document.getElementById('allyB64').value  = allyB64;
    document.getElementById('enemyB64').value = enemyB64;

    // 상태/포커스
    progress.finish(true, res.corners ? '완료' : '코너 미검출');
    st.textContent = res.corners ? '완료' : '코너를 찾지 못했습니다';
    document.getElementById('allyB64').focus();
  } catch (err) {
    console.error(err);
    alert('오류가 발생했습니다: ' + (err?.message || err));
    progress.finish(false, '에러');
    st.textContent = '에러';
  } finally {
    runBtn.disabled = false;
  }
});
</script>
</body>
</html>
