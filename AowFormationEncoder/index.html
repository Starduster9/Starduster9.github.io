<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>편성 인코더 (초간단)</title>
<style>
  :root { --gap: 14px; }
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 0; background:#f4f5f7; }
  .wrap { max-width: 980px; margin: 24px auto; padding: 0 var(--gap); }
  h1 { font-size: 26px; margin: 0 0 12px; text-align: center; }
  .card { background:#fff; border-radius:16px; box-shadow: 0 6px 20px rgba(0,0,0,0.06); padding: 20px; margin-bottom: var(--gap); }
  .row { display: grid; grid-template-columns: 1fr; gap: var(--gap); }
  .grid { display:grid; grid-template-columns: 1fr 1fr; gap: var(--gap); }
  @media (max-width: 900px){ .grid{ grid-template-columns: 1fr; } }
  label.block { display:block; font-size:18px; margin-bottom: 6px; }
  input[type="file"] { font-size:16px; padding:10px; width:100%; background:#fafafa; border:1px solid #e5e7eb; border-radius:10px; }
  button.big { width:100%; font-size:20px; padding:16px; border:0; border-radius:12px; background:#2563eb; color:#fff; cursor:pointer; }
  button.big:disabled { background:#9ca3af; cursor:not-allowed; }
  .help { font-size:15px; color:#4b5563; margin-top:8px; }
  canvas { width:100%; background:#111; border-radius:12px; }
  .result { display:flex; flex-direction:column; gap:10px; }
  textarea { width:100%; min-height:120px; font-size:16px; padding:12px; border:1px solid #e5e7eb; border-radius:12px; resize:vertical; }
  .row-cols-2 { display:grid; grid-template-columns: 1fr 1fr; gap: var(--gap); }
  .copy-btn { font-size:16px; padding:10px 12px; border-radius:10px; border:1px solid #d1d5db; background:#f9fafb; cursor:pointer; width: 120px; }
  .status { font-size:16px; color:#111827; background:#f3f4f6; border-radius:10px; padding:10px 12px; }
  .ok { color:#065f46; }
  .bad { color:#991b1b; }
</style>
</head>
<body>
  <div class="wrap">
    <h1>편성 인코더 (초간단)</h1>

    <div class="card grid">
      <div>
        <label class="block">① 스크린샷 선택</label>
        <input id="imgInput" type="file" accept="image/*" />
        <div class="help">전투 편성 화면(7×7 격자) 스크린샷을 넣으세요.</div>
      </div>
      <div>
        <label class="block">② 템플릿 폴더 선택</label>
        <input id="tmplInput" type="file" webkitdirectory directory />
        <div class="help">숫자이름의 PNG들 (예: <code>152.png</code>) 들어있는 폴더.</div>
      </div>
    </div>

    <div class="card">
      <button id="runBtn" class="big" disabled>③ 인식 시작</button>
      <div id="status" class="status" style="margin-top:10px;">이미지와 템플릿을 먼저 선택하세요.</div>
    </div>

    <div class="card grid">
      <div>
        <canvas id="preview" height="600"></canvas>
        <div class="help">미리보기(좌표 박스 표시)</div>
      </div>
      <div class="result">
        <div class="row-cols-2">
          <div>
            <label class="block">JSON 결과</label>
          </div>
          <div style="text-align:right">
            <button class="copy-btn" id="copyJson">복사</button>
          </div>
        </div>
        <textarea id="jsonOut" readonly></textarea>

        <div class="row-cols-2">
          <div>
            <label class="block">BASE64 결과</label>
          </div>
          <div style="text-align:right">
            <button class="copy-btn" id="copyB64">복사</button>
          </div>
        </div>
        <textarea id="b64Out" readonly></textarea>
      </div>
    </div>
  </div>

  <!-- 같은 폴더에 opencv.js 파일 필요 -->
  <script src="opencv.js"></script>
  <script>
    // ====== 설정 ======
    const GRID_SIZE = 7;
    const NUM_CELLS = GRID_SIZE * GRID_SIZE;
    const AREA_TOL = 0.10;
    const TARGET_EMPTY_RGB = [246, 238, 213]; // 빈칸색 (R,G,B)

    // ====== DOM ======
    const imgInput = document.getElementById('imgInput');
    const tmplInput = document.getElementById('tmplInput');
    const runBtn = document.getElementById('runBtn');
    const statusEl = document.getElementById('status');
    const canvas = document.getElementById('preview');
    const ctx = canvas.getContext('2d');
    const jsonOut = document.getElementById('jsonOut');
    const b64Out = document.getElementById('b64Out');
    const copyJson = document.getElementById('copyJson');
    const copyB64 = document.getElementById('copyB64');

    let userImage = null;      // HTMLImageElement
    let tmplMats = {};         // { "152": cv.Mat(gray) }

    function setStatus(msg, ok=false) {
      statusEl.innerHTML = msg;
      statusEl.classList.toggle('ok', ok);
      statusEl.classList.toggle('bad', !ok);
    }

    function enableRunIfReady() {
      runBtn.disabled = !(userImage && Object.keys(tmplMats).length > 0);
      if (!runBtn.disabled) setStatus('준비 완료! "③ 인식 시작"을 누르세요.', true);
    }

    // =========== 파일 로드 ===========
    imgInput.addEventListener('change', async (e) => {
      const f = e.target.files && e.target.files[0];
      if (!f) return;
      userImage = await fileToImage(f);
      // 캔버스에 맞게 그리기
      const ratio = userImage.width / userImage.height;
      canvas.width = Math.min(900, userImage.width);
      canvas.height = Math.round(canvas.width / ratio);
      ctx.drawImage(userImage, 0, 0, canvas.width, canvas.height);
      setStatus('이미지 로드됨.');
      enableRunIfReady();
    });

    tmplInput.addEventListener('change', async (e) => {
      tmplMats = {};
      const files = Array.from(e.target.files || []).filter(f => /\.png$/i.test(f.name));
      if (files.length === 0) { setStatus('템플릿 PNG를 찾지 못했습니다.'); return; }

      // 순차 로드 (단순/안정)
      for (const f of files) {
        const name = f.name.replace(/\.png$/i,'');
        try {
          const img = await fileToImage(f);
          const mat = cv.imread(imgToCanvas(img)); // RGBA
          const gray = new cv.Mat();
          cv.cvtColor(mat, gray, cv.COLOR_RGBA2GRAY);
          tmplMats[name] = gray;  // 보관
          mat.delete();
        } catch (err) {
          console.warn('템플릿 로드 실패:', f.name, err);
        }
      }
      const n = Object.keys(tmplMats).length;
      if (n === 0) setStatus('유효한 템플릿이 없습니다.');
      else setStatus(`템플릿 ${n}개 로드됨.`, true);
      enableRunIfReady();
    });

    // =========== 유틸 ===========
    function fileToImage(file) {
      return new Promise((resolve, reject) => {
        const url = URL.createObjectURL(file);
        const img = new Image();
        img.onload = () => { URL.revokeObjectURL(url); resolve(img); };
        img.onerror = reject;
        img.src = url;
      });
    }

    function imgToCanvas(img) {
      const c = document.createElement('canvas');
      c.width = img.width; c.height = img.height;
      const cctx = c.getContext('2d');
      cctx.drawImage(img, 0, 0);
      return c;
    }

    function mse(a, b) {
      // a,b: cv.Mat(gray, same size)
      const diff = new cv.Mat();
      cv.absdiff(a, b, diff);
      cv.multiply(diff, diff, diff);
      const mean = cv.mean(diff)[0];
      diff.delete();
      return mean;
    }

    function toBase64(str) {
      return btoa(unescape(encodeURIComponent(str)));
    }

    // =========== 핵심 파이프라인 ===========
    async function run() {
      try {
        setStatus('처리 중… 잠시만요.');

        // 1) 입력 이미지 Mat(RGBA -> RGB)
        const srcRGBA = cv.imread(imgToCanvas(userImage));
        const src = new cv.Mat();
        cv.cvtColor(srcRGBA, src, cv.COLOR_RGBA2RGB);
        srcRGBA.delete();

        // 2) non-empty mask (빈칸 RGB와 정확히 같은 픽셀을 배경으로 간주)
        const mask = new cv.Mat.zeros(src.rows, src.cols, cv.CV_8UC1);
        for (let y=0; y<src.rows; y++) {
          for (let x=0; x<src.cols; x++) {
            const r = src.ucharPtr(y,x)[0];
            const g = src.ucharPtr(y,x)[1];
            const b = src.ucharPtr(y,x)[2];
            const isBG = (r===TARGET_EMPTY_RGB[0] && g===TARGET_EMPTY_RGB[1] && b===TARGET_EMPTY_RGB[2]);
            mask.ucharPtr(y,x)[0] = isBG ? 0 : 255;
          }
        }

        // 3) 가장 큰 배경성분 제거(배경 마스크 정제)
        const labels = new cv.Mat(), stats = new cv.Mat(), centroids = new cv.Mat();
        let num = cv.connectedComponentsWithStats(mask, labels, stats, centroids, 4, cv.CV_32S);
        // 배경성분(0 제외) 중 가장 큰 것 찾아서 "배경"으로 간주 → 반전하여 non-empty
        if (num > 1) {
          let maxIdx = 1, maxArea = stats.intPtr(1, cv.CC_STAT_AREA)[0];
          for (let i=2; i<num; i++) {
            const a = stats.intPtr(i, cv.CC_STAT_AREA)[0];
            if (a > maxArea) { maxArea = a; maxIdx = i; }
          }
          const refinedBG = new cv.Mat.zeros(mask.rows, mask.cols, cv.CV_8UC1);
          for (let y=0; y<mask.rows; y++) {
            for (let x=0; x<mask.cols; x++) {
              refinedBG.ucharPtr(y,x)[0] = (labels.intPtr(y,x)[0] === maxIdx) ? 255 : 0;
            }
          }
          // non-empty = !refinedBG
          for (let y=0; y<mask.rows; y++) {
            for (let x=0; x<mask.cols; x++) {
              mask.ucharPtr(y,x)[0] = refinedBG.ucharPtr(y,x)[0] ? 0 : 255;
            }
          }
          refinedBG.delete();
        }
        labels.delete(); stats.delete(); centroids.delete();

        // 4) 최종 마스크로 연결요소
        const L = new cv.Mat(), S = new cv.Mat(), C = new cv.Mat();
        num = cv.connectedComponentsWithStats(mask, L, S, C, 4, cv.CV_32S);

        // 5) 격자 성분 선택 (49개 목표)
        // 5-1 면적 배열
        let areas = [];
        for (let i=1; i<num; i++) areas.push(S.intPtr(i, cv.CC_STAT_AREA)[0]);
        if (areas.length === 0) throw new Error('연결요소가 없습니다.');

        // 면적 중앙값 ± tolerence
        areas.sort((a,b)=>a-b);
        const med = areas[Math.floor(areas.length/2)];
        const lo = med * (1-AREA_TOL), hi = med * (1+AREA_TOL);

        let candidates = [];
        for (let i=1; i<num; i++) {
          const a = S.intPtr(i, cv.CC_STAT_AREA)[0];
          if (a>=lo && a<=hi) candidates.push(i);
        }
        if (candidates.length < NUM_CELLS) {
          // 부족하면 큰 면적부터 채우기
          const all = Array.from({length:num-1}, (_,k)=>k+1).sort((i,j)=>{
            return S.intPtr(j, cv.CC_STAT_AREA)[0] - S.intPtr(i, cv.CC_STAT_AREA)[0];
          });
          candidates = all.slice(0, Math.min(NUM_CELLS, all.length));
        } else {
          // 충분하면 중앙값 근처 중 큰 것부터
          candidates.sort((i,j)=>{
            return S.intPtr(j, cv.CC_STAT_AREA)[0] - S.intPtr(i, cv.CC_STAT_AREA)[0];
          });
          candidates = candidates.slice(0, NUM_CELLS);
        }
        if (candidates.length < NUM_CELLS) {
          setStatus(`경고: 연결요소가 부족함 (${candidates.length}/${NUM_CELLS}). 가능한 만큼 진행합니다.`, false);
        } else {
          setStatus('인식 중…', true);
        }

        // 6) row-major 정렬
        const pts = candidates.map(i => {
          const cx = C.doublePtr(i, 0)[0];
          const cy = C.doublePtr(i, 1)[0];
          return {i, cx, cy};
        });
        const ys = pts.map(p=>p.cy);
        const yMin = Math.min(...ys), yMax = Math.max(...ys);
        const rowStep = (yMax - yMin + 1e-6) / GRID_SIZE;
        function rowIndex(y){ let r = Math.floor((y - yMin)/rowStep); return Math.max(0, Math.min(GRID_SIZE-1, r)); }
        pts.sort((a,b)=> (rowIndex(a.cy) - rowIndex(b.cy)) || (a.cx - b.cx));
        const ordered = pts.map(p=>p.i);

        // 7) 디버그 박스 그리기 (미리보기)
        // 원본 축소 그리기
        ctx.drawImage(userImage, 0, 0, canvas.width, canvas.height);
        function drawRect(x,y,w,h,color="#00E5FF"){
          ctx.strokeStyle = color;
          ctx.lineWidth = 3;
          const sx = x * (canvas.width/src.cols);
          const sy = y * (canvas.height/src.rows);
          const sw = w * (canvas.width/src.cols);
          const sh = h * (canvas.height/src.rows);
          ctx.strokeRect(sx, sy, sw, sh);
        }
        for (const lbl of ordered) {
          const x = S.intPtr(lbl, cv.CC_STAT_LEFT)[0];
          const y = S.intPtr(lbl, cv.CC_STAT_TOP)[0];
          const w = S.intPtr(lbl, cv.CC_STAT_WIDTH)[0];
          const h = S.intPtr(lbl, cv.CC_STAT_HEIGHT)[0];
          drawRect(x,y,w,h);
        }

        // 8) 패치 추출 + 템플릿 매칭
        const layout = {};
        for (let idx=0; idx<ordered.length; idx++){
          const lbl = ordered[idx];
          const x = S.intPtr(lbl, cv.CC_STAT_LEFT)[0];
          const y = S.intPtr(lbl, cv.CC_STAT_TOP)[0];
          const w = S.intPtr(lbl, cv.CC_STAT_WIDTH)[0];
          const h = S.intPtr(lbl, cv.CC_STAT_HEIGHT)[0];

          const roi = src.roi(new cv.Rect(x,y,w,h));
          const gray = new cv.Mat();
          cv.cvtColor(roi, gray, cv.COLOR_RGB2GRAY);

          // 내부 관심영역 (H:20~60%, W:10~90%)
          const y0 = Math.floor(h*0.20), y1=Math.floor(h*0.60);
          const x0 = Math.floor(w*0.10), x1=Math.floor(w*0.90);
          const roi2 = gray.roi(new cv.Rect(x0,y0, Math.max(1,x1-x0), Math.max(1,y1-y0)));

          // 템플릿과 MSE로 최솟값 찾기
          let bestCode = null, bestScore = Number.POSITIVE_INFINITY;
          const ph = roi2.rows, pw = roi2.cols;
          for (const [code, tmat] of Object.entries(tmplMats)){
            const resized = new cv.Mat();
            cv.resize(tmat, resized, new cv.Size(pw, ph), 0, 0, cv.INTER_AREA);
            const s = mse(roi2, resized);
            if (s < bestScore){ bestScore = s; bestCode = code; }
            resized.delete();
          }
          roi2.delete(); gray.delete(); roi.delete();

          const r = Math.floor(idx/GRID_SIZE), c = idx%GRID_SIZE;
          layout[`${r}${c}`] = parseInt(bestCode ?? '0', 10);
        }

        // 9) 페이로드 + JSON/BASE64 출력
        const payload = {
          GameMode: 0,
          troopLayout: layout,
          heroLayout: {},
          armyLayout: null
        };
        const json = JSON.stringify(payload, null, 2);
        jsonOut.value = json;
        b64Out.value = toBase64(JSON.stringify(payload));

        setStatus('완료! 결과가 생성되었습니다 ✅', true);

        // 정리
        src.delete(); mask.delete(); L.delete(); S.delete(); C.delete();
      } catch (err) {
        console.error(err);
        setStatus('오류: ' + (err && err.message ? err.message : err), false);
      }
    }

    runBtn.addEventListener('click', run);

    copyJson.addEventListener('click', async ()=>{
      try { await navigator.clipboard.writeText(jsonOut.value); copyJson.textContent='복사됨'; setTimeout(()=>copyJson.textContent='복사',1200); } catch {}
    });
    copyB64.addEventListener('click', async ()=>{
      try { await navigator.clipboard.writeText(b64Out.value); copyB64.textContent='복사됨'; setTimeout(()=>copyB64.textContent='복사',1200); } catch {}
    });

    // OpenCV 준비되면 안내
    cv['onRuntimeInitialized'] = () => {
      setStatus('OpenCV 준비 완료. 이미지/템플릿을 선택하세요.', true);
    };
  </script>
</body>
</html>
